#############################################################################
## FEATURE COMMITS, 'DEVELOP' TARGETED PULL REQUESTS, PRE-RELEASE TAGS
#############################################################################

# https://gitlab.com/gitlab-org/gitlab/-/issues/206960
# https://docs.gitlab.com/ee/ci/jobs/job_control.html#cicd-variable-expressions
.default_rules:
  rules:
    - if: $CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME == "develop"
    - if: $CI_COMMIT_BRANCH &&
          ($CI_COMMIT_BRANCH != "main") &&
          ($CI_COMMIT_BRANCH != "develop") &&
          ($CI_PIPELINE_SOURCE != "external_pull_request_event")
    - if: $CI_COMMIT_TAG
      when: never

.default_db_rules:
  rules:
    - if: $CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME == "develop"
    - if: $CI_COMMIT_BRANCH &&
          ($CI_COMMIT_BRANCH != "main") &&
          ($CI_COMMIT_BRANCH != "develop") &&
          ($CI_PIPELINE_SOURCE != "external_pull_request_event")
      changes:
        - database/*
    - if: $CI_COMMIT_TAG
      when: never

.develop_pr_rules:
  rules:
    - if: $CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME == "develop"
    - if: $CI_COMMIT_TAG
      when: never

.develop_pr_manual_rules:
  rules:
    - if: $CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME == "develop"
      when: manual
    - if: $CI_COMMIT_TAG
      when: never

.develop_commit_rules:
  rules:
    - if: $CI_COMMIT_BRANCH &&
          ($CI_COMMIT_BRANCH == "develop") &&
          ($CI_PIPELINE_SOURCE != "external_pull_request_event")
    - if: $CI_COMMIT_TAG
      when: never

.pre-release_rules:
  rules:
    - if: $CI_COMMIT_TAG =~ /^(?<MAJOR>(?:0|(?:[1-9]\d*)))\.(?<MINOR>(?:0|(?:[1-9]\d*)))\.(?<PATCH>(?:0|(?:[1-9]\d*)))(?:-(?<prerelease>(alpha|beta|rc)((\.)?(\d+))?))$/
check-default-rules:
  stage: .pre
  interruptible: true
  allow_failure: true
  rules:
    - !reference [ .default_rules, rules ]
  script:
    - echo $CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME
    - echo $CI_COMMIT_TAG
    - if [ "$CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME" == "develop" ];
      then echo "external pull request target branch is 'develop'";
      else echo "external pull request target branch '$CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME' != 'develop'"; fi
    - if [ "$CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME" != "develop" ];
      then echo "external pull request target branch is not 'develop'";
      else echo "external pull request target branch '$CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME' == 'develop'"; fi
    - echo $CI_COMMIT_BRANCH
    - echo $CI_PIPELINE_SOURCE
    - echo $CI_COMMIT_TAG
    - if [ -n "$CI_COMMIT_BRANCH" ];
      then echo "commit branch string length is nonzero";
      else echo "commit branch = '$CI_COMMIT_BRANCH'"; fi
    - if [ -z "$CI_COMMIT_BRANCH" ];
      then echo "commit branch string length is zero";
      else echo "commit branch = '$CI_COMMIT_BRANCH'"; fi
    - if [ "$CI_COMMIT_BRANCH" != "main" ];
      then echo "commit branch is not 'main'";
      else echo "'$CI_COMMIT_BRANCH' == 'main'"; fi
    - if [ "$CI_COMMIT_BRANCH" = "main" ];
      then echo "commit branch is 'main'";
      else echo "'$CI_COMMIT_BRANCH' != 'main'"; fi
    - if [ "$CI_COMMIT_BRANCH" != "develop" ];
      then echo "commit branch is not 'develop'";
      else echo "'$CI_COMMIT_BRANCH' == 'develop'"; fi
    - if [ "$CI_COMMIT_BRANCH" = "develop" ];
      then echo "commit branch is 'develop'";
      else echo "'$CI_COMMIT_BRANCH' != 'develop'"; fi
    - if [ "$CI_PIPELINE_SOURCE" != "external_pull_request_event" ];
      then echo "pipeline source is not 'external_pull_request_event'";
      else echo "'$CI_PIPELINE_SOURCE' == 'external_pull_request_event'"; fi
    - if [ "$CI_PIPELINE_SOURCE" = "external_pull_request_event" ];
      then echo "pipeline source is 'external_pull_request_event'" ;
      else echo "'$CI_PIPELINE_SOURCE' != 'external_pull_request_event'"; fi
    - if [ -n "$CI_COMMIT_BRANCH" ] &&
          [ "$CI_COMMIT_BRANCH" != "main" ] &&
          [ "$CI_COMMIT_BRANCH" != "develop" ] &&
          [ "$CI_PIPELINE_SOURCE" != "external_pull_request_event" ];
      then echo "commit branch exists, isn't 'main', isn't 'develop', and it's not an external pull request";
      else echo "commit branch = '$CI_COMMIT_BRANCH', pipeline source = '$CI_PIPELINE_SOURCE'"; fi
    - if [ -z "$CI_COMMIT_BRANCH" ] ||
          [ "$CI_COMMIT_BRANCH" = "main" ] ||
          [ "$CI_COMMIT_BRANCH" = "develop" ] ||
          [ "$CI_PIPELINE_SOURCE" = "external_pull_request_event" ];
      then echo "commit branch doesn't exist or is 'main' or is 'develop' or it's an external pull request";
      else echo "commit branch = '$CI_COMMIT_BRANCH', pipeline source = '$CI_PIPELINE_SOURCE'"; fi
    - if [ -z "$CI_COMMIT_TAG" ];
      then echo "commit tag string length is zero";
      else echo "commit tag = '$CI_COMMIT_TAG'"; fi
    - if [ -n "$CI_COMMIT_TAG" ];
      then echo "commit tag string length is nonzero";
      else echo "commit tag = '$CI_COMMIT_TAG'"; fi

check-develop-pr-rules:
  stage: .pre
  interruptible: true
  allow_failure: true
  rules:
    - !reference [ .develop_pr_rules, rules ]
  script:
    - echo $CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME
    - echo $CI_COMMIT_TAG
    - if [ "$CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME" == "develop" ];
      then echo "external pull request target branch is 'develop'";
      else echo "external pull request target branch '$CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME' != 'develop'"; fi
    - if [ "$CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME" != "develop" ];
      then echo "external pull request target branch is not 'develop'";
      else echo "external pull request target branch '$CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME' == 'develop'"; fi
    - if [ -z "$CI_COMMIT_TAG" ];
      then echo "commit tag string length is zero";
      else echo "commit tag = '$CI_COMMIT_TAG'"; fi
    - if [ -n "$CI_COMMIT_TAG" ];
      then echo "commit tag string length is nonzero";
      else echo "commit tag = '$CI_COMMIT_TAG'"; fi

check-develop-commit-rules:
  stage: .pre
  interruptible: true
  allow_failure: true
  rules:
    - !reference [ .develop_commit_rules, rules ]
  script:
    - echo $CI_COMMIT_BRANCH
    - echo $CI_PIPELINE_SOURCE
    - echo $CI_COMMIT_TAG
    - if [ -n "$CI_COMMIT_BRANCH" ];
      then echo "commit branch string length is nonzero";
      else echo "commit branch = '$CI_COMMIT_BRANCH'"; fi
    - if [ -z "$CI_COMMIT_BRANCH" ];
      then echo "commit branch string length is zero";
      else echo "commit branch = '$CI_COMMIT_BRANCH'"; fi
    - if [ "$CI_COMMIT_BRANCH" = "develop" ];
      then echo "commit branch is 'develop'";
      else echo "'$CI_COMMIT_BRANCH' != 'develop'"; fi
    - if [ "$CI_COMMIT_BRANCH" != "develop" ];
      then echo "commit branch is not 'develop'";
      else echo "'$CI_COMMIT_BRANCH' == 'develop'"; fi
    - if [ "$CI_PIPELINE_SOURCE" != "external_pull_request_event" ];
      then echo "pipeline source is not 'external_pull_request_event'";
      else echo "'$CI_PIPELINE_SOURCE' == 'external_pull_request_event'"; fi
    - if [ "$CI_PIPELINE_SOURCE" = "external_pull_request_event" ];
      then echo "pipeline source is 'external_pull_request_event'";
      else echo "'$CI_PIPELINE_SOURCE' != 'external_pull_request_event'"; fi
    - if [ -n "$CI_COMMIT_BRANCH" ] &&
          [ "$CI_COMMIT_BRANCH" = "develop" ] &&
          [ "$CI_PIPELINE_SOURCE" != "external_pull_request_event" ];
      then echo "commit branch exists, is 'develop', and it's not an external pull request";
      else echo "commit branch = '$CI_COMMIT_BRANCH', pipeline source = '$CI_PIPELINE_SOURCE'"; fi
    - if [ -z "$CI_COMMIT_BRANCH" ] ||
          [ "$CI_COMMIT_BRANCH" != "develop" ] ||
          [ "$CI_PIPELINE_SOURCE" = "external_pull_request_event" ];
      then echo "commit branch doesn't exist or isn't 'develop' or it's an external pull request";
      else echo "commit branch = '$CI_COMMIT_BRANCH', pipeline source = '$CI_PIPELINE_SOURCE'"; fi
    - if [ -z "$CI_COMMIT_TAG" ];
      then echo "commit tag string length is zero";
      else echo "commit tag = '$CI_COMMIT_TAG'"; fi
    - if [ -n "$CI_COMMIT_TAG" ];
      then echo "commit tag string length is nonzero";
      else echo "commit tag = '$CI_COMMIT_TAG'"; fi

check-pre-release-rules:
  stage: .pre
  interruptible: true
  allow_failure: true
  rules:
    - !reference [ .pre-release_rules, rules ]
  before_script:
    - PRERELEASE_REGEX="^(0|([1-9][0-9]*))\.(0|([1-9][0-9]*))\.(0|([1-9][0-9]*))(-((alpha|beta|rc)((\.)?([0-9]+))?))$"
  script:
    - echo $PRERELEASE_REGEX
    - if [[ $CI_COMMIT_TAG =~ $PRERELEASE_REGEX ]];
      then echo "$CI_COMMIT_TAG is a valid pre-release tag.";
      else echo "$CI_COMMIT_TAG is not a valid pre-release tag!"; fi

install-dependencies:
  stage: build
  interruptible: true
  rules:
    - !reference [ .default_rules, rules ]
  needs: []
  cache:
    key:
      files:
        - package-lock.json
    paths:
      - node_modules
      - .npm/
      - cache/Cypress
  script:
    - npm ci --cache .npm --prefer-offline --no-fund
  artifacts:
    paths:
      - node_modules
      - cache/Cypress

build-cicd-base-image:
  stage: build
  rules:
    - if: $CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME == "develop"
      changes:
        - .gitlab-ci/CICD.Dockerfile
    - if: $CI_COMMIT_BRANCH &&
        ($CI_COMMIT_BRANCH != "main") &&
        ($CI_COMMIT_BRANCH != "develop") &&
        ($CI_PIPELINE_SOURCE != "external_pull_request_event")
      changes:
        - .gitlab-ci.yml
        - .gitlab-ci/CICD.Dockerfile
    - if: $CI_COMMIT_TAG
      when: never
  needs: []
  image: $DOCKER_IMAGE
  services:
    - name: $DOCKER_SERVICE
      entrypoint: [ "sh", "-c", "dockerd-entrypoint.sh $DOCKER_DAEMON_OPTIONS" ]
      alias: docker
  before_script:
    - ip a | grep mtu
    - docker network inspect bridge | grep mtu
    - docker login -u $CI_DEPENDENCY_PROXY_USER -p $CI_DEPENDENCY_PROXY_PASSWORD $CI_DEPENDENCY_PROXY_SERVER
    - echo "$REGISTRY_PASSWORD" | docker login -u $REGISTRY_USER --password-stdin $REGISTRY
  script:
    - docker build
          --progress plain
          --pull
          --build-arg REGISTRY_PATH=${DOCKER_HUB_PROXY}
          --build-arg BASE_IMAGE=${BASE_IMAGE}
          --build-arg BUILDKIT_INLINE_CACHE=1
          --cache-from ${CI_REGISTRY_IMAGE}/${CICD_BASE_IMAGE}
          -f .gitlab-ci/CICD.Dockerfile
          -t ${CI_REGISTRY_IMAGE}/${CICD_BASE_IMAGE}
        .
    - docker push -q ${CI_REGISTRY_IMAGE}/${CICD_BASE_IMAGE}
  after_script:
    - docker logout $CI_DEPENDENCY_PROXY_SERVER
    - docker logout $REGISTRY

build-e2e-base-image:
  stage: build
  rules:
    - if: $CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME == "develop"
      changes:
        - .gitlab-ci.yml
        - .gitlab-ci/E2E.Dockerfile
    - if: $CI_COMMIT_TAG
      when: never
  needs: []
  image: $DOCKER_IMAGE
  services:
    - name: $DOCKER_SERVICE
      entrypoint: [ "sh", "-c", "dockerd-entrypoint.sh $DOCKER_DAEMON_OPTIONS" ]
      alias: docker
  before_script:
    - ip a | grep mtu
    - docker network inspect bridge | grep mtu
    - docker login -u $CI_DEPENDENCY_PROXY_USER -p $CI_DEPENDENCY_PROXY_PASSWORD $CI_DEPENDENCY_PROXY_SERVER
    - echo "$REGISTRY_PASSWORD" | docker login -u $REGISTRY_USER --password-stdin $REGISTRY
  script:
    - docker build
          --progress plain
          --pull
          --build-arg REGISTRY_PATH=${DOCKER_HUB_PROXY}
          --build-arg BASE_IMAGE=${CYPRESS_IMAGE}
          --build-arg BUILDKIT_INLINE_CACHE=1
          --cache-from ${CI_REGISTRY_IMAGE}/${E2E_BASE_IMAGE}
          -f .gitlab-ci/E2E.Dockerfile
          -t ${CI_REGISTRY_IMAGE}/${E2E_BASE_IMAGE}
        .
    - docker push -q ${CI_REGISTRY_IMAGE}/${E2E_BASE_IMAGE}
  after_script:
    - docker logout $CI_DEPENDENCY_PROXY_SERVER
    - docker logout $REGISTRY

.distributed:
  interruptible: true
  rules:
    - !reference [ .default_rules, rules ]
  needs:
    - install-dependencies
  artifacts:
    paths:
      - node_modules/.cache/nx
      - cache/Cypress

build-db-image:
  stage: build
  interruptible: true
  rules:
    - !reference [ .default_db_rules, rules ]
  image: $DOCKER_IMAGE
  services:
    - name: $DOCKER_SERVICE
      entrypoint: [ "sh", "-c", "dockerd-entrypoint.sh $DOCKER_DAEMON_OPTIONS" ]
      alias: docker
  variables:
    DB_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-db"
  before_script:
    - ip a | grep mtu
    - docker network inspect bridge | grep mtu
    - docker login -u $CI_DEPENDENCY_PROXY_USER -p $CI_DEPENDENCY_PROXY_PASSWORD $CI_DEPENDENCY_PROXY_SERVER
    - echo "$REGISTRY_PASSWORD" | docker login -u $REGISTRY_USER --password-stdin $REGISTRY
  script:
    - docker build
          --progress plain
          --pull
          --build-arg REGISTRY_PATH=${DOCKER_HUB_PROXY}
          --build-arg BUILDKIT_INLINE_CACHE=1
          --cache-from ${DB_IMAGE_NAME}:latest
          -f database/Postgres.Dockerfile
          -t ${DB_IMAGE_NAME}:${CI_COMMIT_SHA}
          -t ${DB_IMAGE_NAME}:latest
        .
    - docker push -q -a ${DB_IMAGE_NAME}
  after_script:
    - docker logout $CI_DEPENDENCY_PROXY_SERVER
    - docker logout $REGISTRY

build-liquibase-image:
  stage: build
  interruptible: true
  rules:
    - !reference [ .default_db_rules, rules ]
  image: $DOCKER_IMAGE
  services:
    - name: $DOCKER_SERVICE
      entrypoint: [ "sh", "-c", "dockerd-entrypoint.sh $DOCKER_DAEMON_OPTIONS" ]
      alias: docker
  variables:
    LIQUIBASE_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-liquibase"
  before_script:
    - ip a | grep mtu
    - docker network inspect bridge | grep mtu
    - docker login -u $CI_DEPENDENCY_PROXY_USER -p $CI_DEPENDENCY_PROXY_PASSWORD $CI_DEPENDENCY_PROXY_SERVER
    - echo "$REGISTRY_PASSWORD" | docker login -u $REGISTRY_USER --password-stdin $REGISTRY
  script:
    - docker build
          --progress plain
          --pull
          --build-arg REGISTRY_PATH=${DOCKER_HUB_PROXY}
          --build-arg BUILDKIT_INLINE_CACHE=1
          --cache-from ${LIQUIBASE_IMAGE_NAME}:latest
          -f database/Liquibase.Dockerfile
          -t ${LIQUIBASE_IMAGE_NAME}:${CI_COMMIT_SHA}
          -t ${LIQUIBASE_IMAGE_NAME}:latest
        .
    - docker push -q -a ${LIQUIBASE_IMAGE_NAME}
  after_script:
    - docker logout $CI_DEPENDENCY_PROXY_SERVER
    - docker logout $REGISTRY

build-app:
  stage: build
  interruptible: true
  extends: .distributed
  rules:
    - !reference [ .default_rules, rules ]
  image: ${CI_REGISTRY_IMAGE}/${CICD_BASE_IMAGE}
  script:
    - npx nx affected --base=HEAD~1 --target=build --parallel=3
  artifacts:
    paths:
      - dist

test-db:
  stage: test-db
  interruptible: true
  rules:
    - !reference [ .default_db_rules, rules ]
  needs:
    - build-db-image
    - build-liquibase-image
  image: $DOCKER_IMAGE
  services:
    - name: $DOCKER_SERVICE
      entrypoint: [ "sh", "-c", "dockerd-entrypoint.sh $DOCKER_DAEMON_OPTIONS" ]
      alias: docker
  before_script:
    - sed -i "s^REGISTRY_PATH=.*$^REGISTRY_PATH=${CI_REGISTRY_IMAGE}/^" .env.studio-lite.template
    - sed -i "s/TAG=.*$/TAG=${CI_COMMIT_SHA}/" .env.studio-lite.template
    - echo "$REGISTRY_PASSWORD" | docker login -u $REGISTRY_USER --password-stdin $REGISTRY
    - docker network create app-net
    - docker compose
          -f docker-compose.studio-lite.yaml
          -f docker-compose.studio-lite.prod.yaml
          --env-file .env.studio-lite.template
        pull --quiet db liquibase
    - docker compose
          -f docker-compose.yaml
          -f docker-compose.studio-lite.prod.yaml
          --env-file .env.studio-lite.template
        up -d db
    - export $(grep -v '^#' .env.studio-lite.template | xargs)
    - docker compose
          -f docker-compose.studio-lite.yaml
          -f docker-compose.studio-lite.prod.yaml
          --env-file .env.studio-lite.template
        run --rm liquibase
          liquibase
              --changelogFile studio-lite.changelog-root.xml
              --url jdbc:postgresql://db:5432/${POSTGRES_DB}
              --username ${POSTGRES_USER}
              --password ${POSTGRES_PASSWORD}
              --classpath changelog
            status
    - docker compose
          -f docker-compose.studio-lite.yaml
          -f docker-compose.studio-lite.prod.yaml
          --env-file .env.studio-lite.template
        run --rm liquibase
          liquibase
              --changelogFile studio-lite.changelog-root.xml
              --url jdbc:postgresql://db:5432/${POSTGRES_DB}
              --username ${POSTGRES_USER}
              --password ${POSTGRES_PASSWORD}
              --classpath changelog
            validate
    - docker compose
          -f docker-compose.studio-lite.yaml
          -f docker-compose.studio-lite.prod.yaml
          --env-file .env.studio-lite.template
        run --rm liquibase
          liquibase
              --changelogFile studio-lite.changelog-root.xml
              --url jdbc:postgresql://db:5432/${POSTGRES_DB}
              --username ${POSTGRES_USER}
              --password ${POSTGRES_PASSWORD}
              --classpath changelog
            updateSQL
  script:
    - docker compose
          -f docker-compose.studio-lite.yaml
          -f docker-compose.studio-lite.prod.yaml
          --env-file .env.studio-lite.template
        run --rm liquibase
          liquibase
              --changelogFile studio-lite.changelog-root.xml
              --url jdbc:postgresql://db:5432/${POSTGRES_DB}
              --username ${POSTGRES_USER}
              --password ${POSTGRES_PASSWORD}
              --classpath changelog
            updateTestingRollback
    - docker compose
          -f docker-compose.studio-lite.yaml
          -f docker-compose.studio-lite.prod.yaml
          --env-file .env.studio-lite.template
        run --rm liquibase
          liquibase
              --changelogFile studio-lite.changelog-root.xml
              --url jdbc:postgresql://db:5432/${POSTGRES_DB}
              --username ${POSTGRES_USER}
              --password ${POSTGRES_PASSWORD}
              --classpath changelog
            history

test-app:
  stage: test-units
  interruptible: true
  allow_failure: true
  extends: .distributed
  rules:
    - !reference [ .default_rules, rules ]
  image: ${CI_REGISTRY_IMAGE}/${CICD_BASE_IMAGE}
  script:
    - npx nx affected --base=HEAD~1 --target=test --parallel=2

test-app-e2e:
  stage: test-e2e
  interruptible: true
  allow_failure: true
  extends: .distributed
  rules:
    - !reference [ .develop_pr_rules, rules ]
  image: ${CI_REGISTRY_IMAGE}/${E2E_BASE_IMAGE}
  services:
      - name: $DOCKER_SERVICE
        entrypoint: [ "sh", "-c", "dockerd-entrypoint.sh $DOCKER_DAEMON_OPTIONS" ]
        alias: docker
  before_script:
    - docker network create app-net
    - echo "$REGISTRY_PASSWORD" | docker login -u $REGISTRY_USER --password-stdin $REGISTRY
    - docker pull --quiet ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-db:${CI_COMMIT_SHA}
    - docker pull --quiet ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-liquibase:${CI_COMMIT_SHA}
    - docker tag ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-db:${CI_COMMIT_SHA} studio-lite-db:latest
    - docker tag ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-liquibase:${CI_COMMIT_SHA} studio-lite-liquibase:latest
    - mv .env.dev.template .env.dev
    - docker compose --env-file .env.dev up -d --no-build --pull never db liquibase
    - npx cypress cache path # show where the Cypress test runner binaries are cached
    - npx cypress cache list # show all installed versions of Cypress binary
    - npx cypress verify
    - export POSTGRES_HOST=docker
  script:
    - npx nx serve api --verbose --watch=false & # start backend
    - npx nx e2e frontend-e2e --prod --browser chrome || ( pkill npx && exit 1 )
  after_script:
    - docker logout $REGISTRY

test-app-e2e-api:
  stage: test-e2e
  interruptible: true
  allow_failure: true
  extends: .distributed
  rules:
    - !reference [ .develop_pr_manual_rules, rules ]
  image: ${CI_REGISTRY_IMAGE}/${E2E_BASE_IMAGE}
  services:
      - name: $DOCKER_SERVICE
        entrypoint: [ "sh", "-c", "dockerd-entrypoint.sh $DOCKER_DAEMON_OPTIONS" ]
        alias: docker
  before_script:
    - docker network create app-net
    - echo "$REGISTRY_PASSWORD" | docker login -u $REGISTRY_USER --password-stdin $REGISTRY
    - docker pull --quiet ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-db:${CI_COMMIT_SHA}
    - docker pull --quiet ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-liquibase:${CI_COMMIT_SHA}
    - docker tag ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-db:${CI_COMMIT_SHA} studio-lite-db:latest
    - docker tag ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-liquibase:${CI_COMMIT_SHA} studio-lite-liquibase:latest
    - mv .env.dev.template .env.dev
    - docker compose --env-file .env.dev up -d --no-build --pull never db liquibase
    - npx cypress cache path # show where the Cypress test runner binaries are cached
    - npx cypress cache list # show all installed versions of Cypress binary
    - npx cypress verify
    - export POSTGRES_HOST=docker
  script:
    - npx nx serve api --verbose --watch=false & # start backend
    - npx nx e2e frontend-e2e
        --prod
        --browser chrome
        --spec "./apps/frontend-e2e/src/e2e/api/*" ||
      ( pkill npx && exit 1 )
  after_script:
    - docker logout $REGISTRY

test-app-e2e-ui-chrome:
  stage: test-e2e
  interruptible: true
  allow_failure: true
  extends: .distributed
  rules:
    - !reference [ .develop_pr_manual_rules, rules ]
  image: ${CI_REGISTRY_IMAGE}/${E2E_BASE_IMAGE}
  services:
    - name: $DOCKER_SERVICE
      entrypoint: [ "sh", "-c", "dockerd-entrypoint.sh $DOCKER_DAEMON_OPTIONS" ]
      alias: docker
  before_script:
    - docker network create app-net
    - echo "$REGISTRY_PASSWORD" | docker login -u $REGISTRY_USER --password-stdin $REGISTRY
    - docker pull --quiet ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-db:${CI_COMMIT_SHA}
    - docker pull --quiet ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-liquibase:${CI_COMMIT_SHA}
    - docker tag ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-db:${CI_COMMIT_SHA} studio-lite-db:latest
    - docker tag ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-liquibase:${CI_COMMIT_SHA} studio-lite-liquibase:latest
    - mv .env.dev.template .env.dev
    - docker compose --env-file .env.dev up -d --no-build --pull never db liquibase
    - npx cypress cache path # show where the Cypress test runner binaries are cached
    - npx cypress cache list # show all installed versions of Cypress binary
    - npx cypress verify
    - export POSTGRES_HOST=docker
  script:
    - npx nx serve api --watch=false & # start backend
    - npx nx e2e frontend-e2e
        --prod
        --browser chrome
        --spec "./apps/frontend-e2e/src/e2e/ui/*" ||
      ( pkill npx && exit 1 )
  after_script:
    - docker logout $REGISTRY

test-app-e2e-ui-chrome-mobile:
  stage: test-e2e
  interruptible: true
  allow_failure: true
  extends: .distributed
  rules:
    - !reference [ .develop_pr_manual_rules, rules ]
  image: ${CI_REGISTRY_IMAGE}/${E2E_BASE_IMAGE}
  services:
    - name: $DOCKER_SERVICE
      entrypoint: [ "sh", "-c", "dockerd-entrypoint.sh $DOCKER_DAEMON_OPTIONS" ]
      alias: docker
  before_script:
    - docker network create app-net
    - echo "$REGISTRY_PASSWORD" | docker login -u $REGISTRY_USER --password-stdin $REGISTRY
    - docker pull --quiet ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-db:${CI_COMMIT_SHA}
    - docker pull --quiet ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-liquibase:${CI_COMMIT_SHA}
    - docker tag ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-db:${CI_COMMIT_SHA} studio-lite-db:latest
    - docker tag ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-liquibase:${CI_COMMIT_SHA} studio-lite-liquibase:latest
    - mv .env.dev.template .env.dev
    - docker compose --env-file .env.dev up -d --no-build --pull never db liquibase
    - npx cypress cache path # show where the Cypress test runner binaries are cached
    - npx cypress cache list # show all installed versions of Cypress binary
    - npx cypress verify
    - export POSTGRES_HOST=docker
  script:
    - npx nx serve api --watch=false & # start backend
    - npx nx e2e frontend-e2e
        --prod
        --browser chrome
        --spec "./apps/frontend-e2e/src/e2e/ui/*"
        --config "viewportWidth=375,viewportHeight=667" ||
      ( pkill npx && exit 1 )
  after_script:
    - docker logout $REGISTRY

test-app-e2e-ui-firefox:
  stage: test-e2e
  interruptible: true
  allow_failure: true
  extends: .distributed
  rules:
    - !reference [ .develop_pr_manual_rules, rules ]
  image: ${CI_REGISTRY_IMAGE}/${E2E_BASE_IMAGE}
  services:
    - name: $DOCKER_SERVICE
      entrypoint: [ "sh", "-c", "dockerd-entrypoint.sh $DOCKER_DAEMON_OPTIONS" ]
      alias: docker
  before_script:
    - docker network create app-net
    - echo "$REGISTRY_PASSWORD" | docker login -u $REGISTRY_USER --password-stdin $REGISTRY
    - docker pull --quiet ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-db:${CI_COMMIT_SHA}
    - docker pull --quiet ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-liquibase:${CI_COMMIT_SHA}
    - docker tag ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-db:${CI_COMMIT_SHA} studio-lite-db:latest
    - docker tag ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-liquibase:${CI_COMMIT_SHA} studio-lite-liquibase:latest
    - mv .env.dev.template .env.dev
    - docker compose --env-file .env.dev up -d --no-build --pull never db liquibase
    - npx cypress cache path # show where the Cypress test runner binaries are cached
    - npx cypress cache list # show all installed versions of Cypress binary
    - npx cypress verify
    - export POSTGRES_HOST=docker
  script:
    - npx nx serve api --watch=false & # start backend
    - npx nx e2e frontend-e2e
        --prod
        --browser firefox
        --spec "./apps/frontend-e2e/src/e2e/ui/*" ||
      ( pkill npx && exit 1 )
  after_script:
    - docker logout $REGISTRY

test-app-e2e-ui-firefox-mobile:
  stage: test-e2e
  interruptible: true
  allow_failure: true
  extends: .distributed
  rules:
    - !reference [ .develop_pr_manual_rules, rules ]
  image: ${CI_REGISTRY_IMAGE}/${E2E_BASE_IMAGE}
  services:
    - name: $DOCKER_SERVICE
      entrypoint: [ "sh", "-c", "dockerd-entrypoint.sh $DOCKER_DAEMON_OPTIONS" ]
      alias: docker
  before_script:
    - docker network create app-net
    - echo "$REGISTRY_PASSWORD" | docker login -u $REGISTRY_USER --password-stdin $REGISTRY
    - docker pull --quiet ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-db:${CI_COMMIT_SHA}
    - docker pull --quiet ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-liquibase:${CI_COMMIT_SHA}
    - docker tag ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-db:${CI_COMMIT_SHA} studio-lite-db:latest
    - docker tag ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-liquibase:${CI_COMMIT_SHA} studio-lite-liquibase:latest
    - mv .env.dev.template .env.dev
    - docker compose --env-file .env.dev up -d --no-build --pull never db liquibase
    - npx cypress cache path # show where the Cypress test runner binaries are cached
    - npx cypress cache list # show all installed versions of Cypress binary
    - npx cypress verify
    - export POSTGRES_HOST=docker
  script:
    - npx nx serve api --watch=false & # start backend
    - npx nx e2e frontend-e2e
        --prod
        --browser firefox
        --spec "./apps/frontend-e2e/src/e2e/ui/*"
        --config "viewportWidth=375,viewportHeight=667" ||
      ( pkill npx && exit 1 )
  after_script:
    - docker logout $REGISTRY

test-app-e2e-ui-edge:
  stage: test-e2e
  interruptible: true
  allow_failure: true
  extends: .distributed
  rules:
    - !reference [ .develop_pr_manual_rules, rules ]
  image: ${CI_REGISTRY_IMAGE}/${E2E_BASE_IMAGE}
  services:
    - name: $DOCKER_SERVICE
      entrypoint: [ "sh", "-c", "dockerd-entrypoint.sh $DOCKER_DAEMON_OPTIONS" ]
      alias: docker
  before_script:
    - docker network create app-net
    - echo "$REGISTRY_PASSWORD" | docker login -u $REGISTRY_USER --password-stdin $REGISTRY
    - docker pull --quiet ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-db:${CI_COMMIT_SHA}
    - docker pull --quiet ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-liquibase:${CI_COMMIT_SHA}
    - docker tag ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-db:${CI_COMMIT_SHA} studio-lite-db:latest
    - docker tag ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-liquibase:${CI_COMMIT_SHA} studio-lite-liquibase:latest
    - mv .env.dev.template .env.dev
    - docker compose --env-file .env.dev up -d --no-build --pull never db liquibase
    - npx cypress cache path # show where the Cypress test runner binaries are cached
    - npx cypress cache list # show all installed versions of Cypress binary
    - npx cypress verify
    - export POSTGRES_HOST=docker
  script:
    - npx nx serve api --watch=false & # start backend
    - npx nx e2e frontend-e2e
        --prod
        --browser edge
        --spec "./apps/frontend-e2e/src/e2e/ui/*" ||
      ( pkill npx && exit 1 )
  after_script:
    - docker logout $REGISTRY

test-app-e2e-ui-edge-mobile:
  stage: test-e2e
  interruptible: true
  allow_failure: true
  extends: .distributed
  rules:
    - !reference [ .develop_pr_manual_rules, rules ]
  image: ${CI_REGISTRY_IMAGE}/${E2E_BASE_IMAGE}
  services:
    - name: $DOCKER_SERVICE
      entrypoint: [ "sh", "-c", "dockerd-entrypoint.sh $DOCKER_DAEMON_OPTIONS" ]
      alias: docker
  before_script:
    - docker network create app-net
    - echo "$REGISTRY_PASSWORD" | docker login -u $REGISTRY_USER --password-stdin $REGISTRY
    - docker pull --quiet ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-db:${CI_COMMIT_SHA}
    - docker pull --quiet ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-liquibase:${CI_COMMIT_SHA}
    - docker tag ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-db:${CI_COMMIT_SHA} studio-lite-db:latest
    - docker tag ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-liquibase:${CI_COMMIT_SHA} studio-lite-liquibase:latest
    - mv .env.dev.template .env.dev
    - docker compose --env-file .env.dev up -d --no-build --pull never db liquibase
    - npx cypress cache path # show where the Cypress test runner binaries are cached
    - npx cypress cache list # show all installed versions of Cypress binary
    - npx cypress verify
    - export POSTGRES_HOST=docker
  script:
    - npx nx serve api --watch=false & # start backend
    - npx nx e2e frontend-e2e
        --prod
        --browser edge
        --spec "./apps/frontend-e2e/src/e2e/ui/*"
        --config "viewportWidth=375,viewportHeight=667" ||
      ( pkill npx && exit 1 )
  after_script:
    - docker logout $REGISTRY

lint-app:
  stage: lint
  extends: .distributed
  interruptible: true
  allow_failure: true
  rules:
    - !reference [ .default_rules, rules ]
  image: ${CI_REGISTRY_IMAGE}/${CICD_BASE_IMAGE}
  script:
    - npx nx affected --base=HEAD~1 --target=lint --parallel=2

audit-app:
  stage: audit
  interruptible: true
  allow_failure: true
  rules:
    - !reference [ .default_rules, rules ]
  needs:
    - install-dependencies
  script:
    - npm audit --audit-level critical

build-develop-commit-db-image:
  stage: build-images
  rules:
    - !reference [ .develop_commit_rules, rules ]
  image: $DOCKER_IMAGE
  services:
    - name: $DOCKER_SERVICE
      entrypoint: [ "sh", "-c", "dockerd-entrypoint.sh $DOCKER_DAEMON_OPTIONS" ]
      alias: docker
  variables:
    DB_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-db"
  before_script:
    - ip a | grep mtu
    - docker network inspect bridge | grep mtu
    - docker login -u $CI_DEPENDENCY_PROXY_USER -p $CI_DEPENDENCY_PROXY_PASSWORD $CI_DEPENDENCY_PROXY_SERVER
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - docker build
          --progress plain
          --pull
          --build-arg REGISTRY_PATH=${DOCKER_HUB_PROXY}
          --build-arg BUILDKIT_INLINE_CACHE=1
          --cache-from ${DB_IMAGE_NAME}:latest
          -f database/Postgres.Dockerfile
          -t ${DB_IMAGE_NAME}:${CI_COMMIT_SHA}
          -t ${DB_IMAGE_NAME}:latest
        .
    - docker push -q -a ${DB_IMAGE_NAME}
  after_script:
    - docker logout $CI_DEPENDENCY_PROXY_SERVER
    - docker logout $CI_REGISTRY

build-develop-commit-liquibase-image:
  stage: build-images
  rules:
    - !reference [ .develop_commit_rules, rules ]
  image: $DOCKER_IMAGE
  services:
    - name: $DOCKER_SERVICE
      entrypoint: [ "sh", "-c", "dockerd-entrypoint.sh $DOCKER_DAEMON_OPTIONS" ]
      alias: docker
  variables:
    LIQUIBASE_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-liquibase"
  before_script:
    - ip a | grep mtu
    - docker network inspect bridge | grep mtu
    - docker login -u $CI_DEPENDENCY_PROXY_USER -p $CI_DEPENDENCY_PROXY_PASSWORD $CI_DEPENDENCY_PROXY_SERVER
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - docker build
          --progress plain
          --pull
          --build-arg REGISTRY_PATH=${DOCKER_HUB_PROXY}
          --build-arg BUILDKIT_INLINE_CACHE=1
          --cache-from ${LIQUIBASE_IMAGE_NAME}:latest
          -f database/Liquibase.Dockerfile
          -t ${LIQUIBASE_IMAGE_NAME}:${CI_COMMIT_SHA}
          -t ${LIQUIBASE_IMAGE_NAME}:latest
        .
    - docker push -q -a ${LIQUIBASE_IMAGE_NAME}
  after_script:
    - docker logout $CI_DEPENDENCY_PROXY_SERVER
    - docker logout $CI_REGISTRY

build-develop-commit-base-image:
  stage: build-images
  rules:
    - !reference [ .develop_commit_rules, rules ]
  image: $DOCKER_IMAGE
  services:
    - name: $DOCKER_SERVICE
      entrypoint: [ "sh", "-c", "dockerd-entrypoint.sh $DOCKER_DAEMON_OPTIONS" ]
      alias: docker
  variables:
    BASE_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-base"
  before_script:
    - ip a | grep mtu
    - docker network inspect bridge | grep mtu
    - docker login -u $CI_DEPENDENCY_PROXY_USER -p $CI_DEPENDENCY_PROXY_PASSWORD $CI_DEPENDENCY_PROXY_SERVER
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - docker build
      --progress plain
      --pull
      --build-arg REGISTRY_PATH=${DOCKER_HUB_PROXY}
      --tag ${BASE_IMAGE_NAME}:${CI_COMMIT_SHA}
      --tag ${BASE_IMAGE_NAME}:latest
      .
    - docker push -q -a ${BASE_IMAGE_NAME}
  after_script:
    - docker logout $CI_DEPENDENCY_PROXY_SERVER
    - docker logout $CI_REGISTRY

build-develop-commit-backend-image:
  stage: build-images
  rules:
    - !reference [ .develop_commit_rules, rules ]
  needs:
    - build-develop-commit-base-image
  image: $DOCKER_IMAGE
  services:
    - name: $DOCKER_SERVICE
      entrypoint: [ "sh", "-c", "dockerd-entrypoint.sh $DOCKER_DAEMON_OPTIONS" ]
      alias: docker
  variables:
    BASE_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-base"
    BACKEND_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-backend"
  before_script:
    - ip a | grep mtu
    - docker network inspect bridge | grep mtu
    - docker login -u $CI_DEPENDENCY_PROXY_USER -p $CI_DEPENDENCY_PROXY_PASSWORD $CI_DEPENDENCY_PROXY_SERVER
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - docker build
          --progress plain
          --pull
          --target=prod
          --build-arg PROJECT=api
          --build-arg REGISTRY_PATH=${DOCKER_HUB_PROXY}
          --build-arg BASE_IMAGE_NAME=${BASE_IMAGE_NAME}:${CI_COMMIT_SHA}
          --build-arg BUILDKIT_INLINE_CACHE=1
          --cache-from ${BACKEND_IMAGE_NAME}:latest
          -f apps/api/Dockerfile
          -t ${BACKEND_IMAGE_NAME}:${CI_COMMIT_SHA}
          -t ${BACKEND_IMAGE_NAME}:latest
        .
    - docker push -q -a ${BACKEND_IMAGE_NAME}
  after_script:
    - docker logout $CI_DEPENDENCY_PROXY_SERVER
    - docker logout $CI_REGISTRY

build-develop-commit-frontend-image:
  stage: build-images
  rules:
    - !reference [ .develop_commit_rules, rules ]
  needs:
    - build-develop-commit-base-image
  image: $DOCKER_IMAGE
  services:
    - name: $DOCKER_SERVICE
      entrypoint: [ "sh", "-c", "dockerd-entrypoint.sh $DOCKER_DAEMON_OPTIONS" ]
      alias: docker
  variables:
    BASE_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-base"
    FRONTEND_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-frontend"
  before_script:
    - ip a | grep mtu
    - docker network inspect bridge | grep mtu
    - docker login -u $CI_DEPENDENCY_PROXY_USER -p $CI_DEPENDENCY_PROXY_PASSWORD $CI_DEPENDENCY_PROXY_SERVER
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - docker build
          --progress plain
          --pull
          --target=prod
          --build-arg PROJECT=frontend
          --build-arg REGISTRY_PATH=${DOCKER_HUB_PROXY}
          --build-arg BASE_IMAGE_NAME=${BASE_IMAGE_NAME}:${CI_COMMIT_SHA}
          --build-arg BUILDKIT_INLINE_CACHE=1
          --cache-from ${FRONTEND_IMAGE_NAME}:latest
          -f apps/frontend/Dockerfile
          -t ${FRONTEND_IMAGE_NAME}:${CI_COMMIT_SHA}
          -t ${FRONTEND_IMAGE_NAME}:latest
        .
    - docker push -q -a ${FRONTEND_IMAGE_NAME}
  after_script:
    - docker logout $CI_DEPENDENCY_PROXY_SERVER
    - docker logout $CI_REGISTRY

scan-develop-commit-db-image:
  stage: scan-images
  allow_failure: true
  rules:
    - !reference [ .develop_commit_rules, rules ]
  needs:
    - build-develop-commit-db-image
  image:
    name: $TRIVY_IMAGE
    entrypoint: [ "" ]
  variables:
    # No need to clone the repo, we exclusively work on artifacts.  See
    # https://docs.gitlab.com/ee/ci/runners/README.html#git-strategy
    GIT_STRATEGY: none
    TRIVY_USERNAME: "$CI_REGISTRY_USER"
    TRIVY_PASSWORD: "$CI_REGISTRY_PASSWORD"
    TRIVY_AUTH_URL: "$CI_REGISTRY"
    TRIVY_NO_PROGRESS: "true"
    TRIVY_CACHE_DIR: ".trivycache/"
    FULL_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-db:${CI_COMMIT_SHA}"
  script:
    - trivy --version
    # cache cleanup is needed when scanning images with the same tags, it does not remove the database
    - trivy clean --scan-cache
    # update vulnerabilities db
    - trivy image --download-db-only --no-progress
    # Builds report and puts it in the default workdir $CI_PROJECT_DIR, so `artifacts:` can take it from there
    - trivy image
          --exit-code 0
          --timeout 30m
          --scanners vuln
          --format template
          --template "@/contrib/gitlab.tpl"
          --output "$CI_PROJECT_DIR/gl-container-scanning-report.json"
        "$FULL_IMAGE_NAME"
    # Prints full report
    - trivy image
          --exit-code 0
          --timeout 30m
          --scanners vuln
        "$FULL_IMAGE_NAME"
    # Fail on critical vulnerabilities
    - trivy image
          --exit-code 1
          --timeout 30m
          --scanners vuln
          --ignore-unfixed
          --severity CRITICAL
        $FULL_IMAGE_NAME
  cache:
    paths:
      - .trivycache/
  # Enables https://docs.gitlab.com/ee/user/application_security/container_scanning/
  artifacts:
    when: always
    reports:
      container_scanning: gl-container-scanning-report.json

scan-develop-commit-liquibase-image:
  stage: scan-images
  allow_failure: true
  rules:
    - !reference [ .develop_commit_rules, rules ]
  needs:
    - build-develop-commit-liquibase-image
  image:
    name: $TRIVY_IMAGE
    entrypoint: [ "" ]
  variables:
    # No need to clone the repo, we exclusively work on artifacts.  See
    # https://docs.gitlab.com/ee/ci/runners/README.html#git-strategy
    GIT_STRATEGY: none
    TRIVY_USERNAME: "$CI_REGISTRY_USER"
    TRIVY_PASSWORD: "$CI_REGISTRY_PASSWORD"
    TRIVY_AUTH_URL: "$CI_REGISTRY"
    TRIVY_NO_PROGRESS: "true"
    TRIVY_CACHE_DIR: ".trivycache/"
    FULL_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-liquibase:${CI_COMMIT_SHA}"
  script:
    - trivy --version
    # cache cleanup is needed when scanning images with the same tags, it does not remove the database
    - trivy clean --scan-cache
    # update vulnerabilities db
    - trivy image --download-db-only --no-progress
    # Builds report and puts it in the default workdir $CI_PROJECT_DIR, so `artifacts:` can take it from there
    - trivy image
          --exit-code 0
          --timeout 30m
          --scanners vuln
          --format template
          --template "@/contrib/gitlab.tpl"
          --output "$CI_PROJECT_DIR/gl-container-scanning-report.json"
        "$FULL_IMAGE_NAME"
    # Prints full report
    - trivy image
          --exit-code 0
          --timeout 30m
          --scanners vuln
        "$FULL_IMAGE_NAME"
    # Fail on critical vulnerabilities
    - trivy image
          --exit-code 1
          --timeout 30m
          --scanners vuln
          --ignore-unfixed
          --severity CRITICAL
        "$FULL_IMAGE_NAME"
  cache:
    paths:
      - .trivycache/
  # Enables https://docs.gitlab.com/ee/user/application_security/container_scanning/
  artifacts:
    when: always
    reports:
      container_scanning: gl-container-scanning-report.json

scan-develop-commit-backend-image:
  stage: scan-images
  allow_failure: true
  rules:
    - !reference [ .develop_commit_rules, rules ]
  needs:
    - build-develop-commit-backend-image
  image:
    name: $TRIVY_IMAGE
    entrypoint: [ "" ]
  variables:
    # No need to clone the repo, we exclusively work on artifacts.  See
    # https://docs.gitlab.com/ee/ci/runners/README.html#git-strategy
    GIT_STRATEGY: none
    TRIVY_USERNAME: "$CI_REGISTRY_USER"
    TRIVY_PASSWORD: "$CI_REGISTRY_PASSWORD"
    TRIVY_AUTH_URL: "$CI_REGISTRY"
    TRIVY_NO_PROGRESS: "true"
    TRIVY_CACHE_DIR: ".trivycache/"
    FULL_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-backend:${CI_COMMIT_SHA}"
  script:
    - trivy --version
    # cache cleanup is needed when scanning images with the same tags, it does not remove the database
    - trivy clean --scan-cache
    # update vulnerabilities db
    - trivy image --download-db-only --no-progress
    # Builds report and puts it in the default workdir $CI_PROJECT_DIR, so `artifacts:` can take it from there
    - trivy image
          --exit-code 0
          --timeout 30m
          --scanners vuln
          --format template
          --template "@/contrib/gitlab.tpl"
          --output "$CI_PROJECT_DIR/gl-container-scanning-report.json"
        "$FULL_IMAGE_NAME"
    # Prints full report
    - trivy image
          --exit-code 0
          --timeout 30m
          --scanners vuln
        "$FULL_IMAGE_NAME"
    # Fail on critical vulnerabilities
    - trivy image
          --exit-code 1
          --timeout 30m
          --scanners vuln
          --ignore-unfixed
          --severity CRITICAL
        "$FULL_IMAGE_NAME"
  cache:
    paths:
      - .trivycache/
  # Enables https://docs.gitlab.com/ee/user/application_security/container_scanning/
  artifacts:
    when: always
    reports:
      container_scanning: gl-container-scanning-report.json

scan-develop-commit-frontend-image:
  stage: scan-images
  allow_failure: true
  rules:
    - !reference [ .develop_commit_rules, rules ]
  needs:
    - build-develop-commit-frontend-image
  image:
    name: $TRIVY_IMAGE
    entrypoint: [ "" ]
  variables:
    # No need to clone the repo, we exclusively work on artifacts.  See
    # https://docs.gitlab.com/ee/ci/runners/README.html#git-strategy
    GIT_STRATEGY: none
    TRIVY_USERNAME: "$CI_REGISTRY_USER"
    TRIVY_PASSWORD: "$CI_REGISTRY_PASSWORD"
    TRIVY_AUTH_URL: "$CI_REGISTRY"
    TRIVY_NO_PROGRESS: "true"
    TRIVY_CACHE_DIR: ".trivycache/"
    FULL_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-frontend:${CI_COMMIT_SHA}"
  script:
    - trivy --version
    # cache cleanup is needed when scanning images with the same tags, it does not remove the database
    - trivy clean --scan-cache
    # update vulnerabilities db
    - trivy image --download-db-only --no-progress
    # Builds report and puts it in the default workdir $CI_PROJECT_DIR, so `artifacts:` can take it from there
    - trivy image
          --exit-code 0
          --timeout 30m
          --scanners vuln
          --format template
          --template "@/contrib/gitlab.tpl"
          --output "$CI_PROJECT_DIR/gl-container-scanning-report.json"
        "$FULL_IMAGE_NAME"
    # Prints full report
    - trivy image
          --exit-code 0
          --timeout 30m
          --scanners vuln
        "$FULL_IMAGE_NAME"
    # Fail on critical vulnerabilities
    - trivy image
          --exit-code 1
          --timeout 30m
          --scanners vuln
          --ignore-unfixed
          --severity CRITICAL
        "$FULL_IMAGE_NAME"
  cache:
    paths:
      - .trivycache/
  # Enables https://docs.gitlab.com/ee/user/application_security/container_scanning/
  artifacts:
    when: always
    reports:
      container_scanning: gl-container-scanning-report.json

build-pre-release:
  stage: build-images
  rules:
    - !reference [ .pre-release_rules, rules ]
  image: $DOCKER_IMAGE
  services:
    - name: $DOCKER_SERVICE
      entrypoint: [ "sh", "-c", "dockerd-entrypoint.sh $DOCKER_DAEMON_OPTIONS" ]
      alias: docker
  variables:
    DB_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-db"
    LIQUIBASE_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-liquibase"
    BACKEND_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-backend"
    FRONTEND_IMAGE_NAME: "${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-frontend"
  before_script:
    - echo "$DOCKERHUB_PASSWORD" | docker login -u $DOCKERHUB_USER --password-stdin
    - docker pull -q ${DB_IMAGE_NAME}:${CI_COMMIT_SHA}
    - docker pull -q ${LIQUIBASE_IMAGE_NAME}:${CI_COMMIT_SHA}
    - docker pull -q ${BACKEND_IMAGE_NAME}:${CI_COMMIT_SHA}
    - docker pull -q ${FRONTEND_IMAGE_NAME}:${CI_COMMIT_SHA}
  script:
    - docker tag ${DB_IMAGE_NAME}:${CI_COMMIT_SHA} iqbberlin/studio-lite-db:${CI_COMMIT_TAG}
    - docker tag ${LIQUIBASE_IMAGE_NAME}:${CI_COMMIT_SHA} iqbberlin/studio-lite-liquibase:${CI_COMMIT_TAG}
    - docker tag ${BACKEND_IMAGE_NAME}:${CI_COMMIT_SHA} iqbberlin/studio-lite-backend:${CI_COMMIT_TAG}
    - docker tag ${FRONTEND_IMAGE_NAME}:${CI_COMMIT_SHA} iqbberlin/studio-lite-frontend:${CI_COMMIT_TAG}
    - docker push -q iqbberlin/studio-lite-db:${CI_COMMIT_TAG}
    - docker push -q iqbberlin/studio-lite-liquibase:${CI_COMMIT_TAG}
    - docker push -q iqbberlin/studio-lite-backend:${CI_COMMIT_TAG}
    - docker push -q iqbberlin/studio-lite-frontend:${CI_COMMIT_TAG}
  after_script:
    - docker logout
