image: node:16.15-bullseye-slim

variables:
  REGISTRY: $CI_REGISTRY
  REGISTRY_USER: $CI_REGISTRY_USER
  REGISTRY_PASSWORD: $CI_REGISTRY_PASSWORD
  REGISTRY_PROJECT: "/${CI_PROJECT_PATH}/"
  DOCKER_IMAGE: "docker:20.10-git"
  DOCKER_SERVICE: "docker:20.10-dind"
  DOCKER_TLS_CERTDIR: ""
  CYPRESS_IMAGE: "cypress/browsers:node16.14.2-slim-chrome100-ff99-edge"
  CYPRESS_CACHE_FOLDER: "$CI_PROJECT_DIR/cache/Cypress"

stages:
  - .pre
  - build
  - unit-test
  - e2e-test
  - lint
  - audit
  - build-images
  - scan-images
  - push-images

.default_rules:
  rules:
    - if: $CI_COMMIT_BRANCH != "main" && $CI_COMMIT_BRANCH != "develop" && $CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME != "main"
    - if: $CI_COMMIT_TAG
      when: never

.default_db_rules:
  rules:
    - if: $CI_COMMIT_BRANCH != "main" && $CI_COMMIT_BRANCH != "develop" && $CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME != "main"
      changes:
        - database/*
    - if: $CI_COMMIT_TAG
      when: never

.default_manual_rules:
  rules:
    - if: $CI_COMMIT_BRANCH != "main" && $CI_COMMIT_BRANCH != "develop" && $CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME != "main"
      when: manual
    - if: $CI_COMMIT_TAG
      when: never

.development_rules:
  rules:
    - if: $CI_COMMIT_BRANCH == "develop" && $CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME != "main"
    - if: $CI_COMMIT_TAG
      when: never

.development_db_rules:
  rules:
    - if: $CI_COMMIT_BRANCH == "develop" && $CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME != "main"
      changes:
        - database/*
    - if: $CI_COMMIT_TAG
      when: never

.prepare_release_rules:
  rules:
    - if: $CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME == "main"
    - if: $CI_COMMIT_TAG
      when: never

.prepare_release_manual_rules:
  rules:
    - if: $CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME == "main"
      when: manual
    - if: $CI_COMMIT_TAG
      when: never

.build_release_rules:
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_TAG
      when: never

.prerelease_push_rules:
  rules:
    - if: $CI_COMMIT_TAG =~ /^(?P<MAJOR>0|[1-9]\d*)\.(?P<MINOR>0|[1-9]\d*)\.(?P<PATCH>0|[1-9]\d*)-(?P<PRERELEASE>(alpha|beta|rc)(?:[1-9]\d*)?)$/

.release_push_rules:
  rules:
    - if: $CI_COMMIT_TAG =~ /^(?P<MAJOR>0|[1-9]\d*)\.(?P<MINOR>0|[1-9]\d*)\.(?P<PATCH>0|[1-9]\d*)$/

check-config:
  stage: .pre
  interruptible: true
  allow_failure: true
  script:
    - echo $CI_COMMIT_BRANCH
    - echo $CI_COMMIT_TAG
    - echo $CI_PIPELINE_SOURCE
    - echo $CI_EXTERNAL_PULL_REQUEST_IID
    - echo $CI_EXTERNAL_PULL_REQUEST_SOURCE_REPOSITORY
    - echo $CI_EXTERNAL_PULL_REQUEST_TARGET_REPOSITORY
    - echo $CI_EXTERNAL_PULL_REQUEST_SOURCE_BRANCH_NAME
    - echo $CI_EXTERNAL_PULL_REQUEST_SOURCE_BRANCH_SHA
    - echo $CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME
    - echo $CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_SHA
    - echo $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME
    - echo $CI_MERGE_REQUEST_TARGET_BRANCH_NAME
    - echo $CI_COMMIT_BEFORE_SHA
    - echo $CI_COMMIT_SHA
    - echo $CI_COMMIT_SHORT_SHA
    - echo $CI_COMMIT_REF_NAME

check-default-rules:
  stage: .pre
  interruptible: true
  allow_failure: true
  rules:
    - if: $CI_COMMIT_BRANCH && $CI_COMMIT_BRANCH != "main" && $CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME != "main"
    - if: $CI_COMMIT_TAG
      when: never
  before_script:
    - PRERELEASE_REGEX="^(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)(-((alpha|beta|rc)([1-9][0-9]*)?))?$"
    - RELEASE_REGEX="^(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)$"
  script:
    - echo $CI_COMMIT_BRANCH
    - echo $CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME
    - echo $CI_COMMIT_TAG
    - if [ "${CI_COMMIT_BRANCH}" != "main" ]; then echo "commit branch is not 'main'" ; else echo "commit branch '$CI_COMMIT_BRANCH' == 'main'"; fi
    - if [ "${CI_COMMIT_BRANCH}" == "main" ]; then echo "commit branch is 'main'" ; else echo "commit branch '$CI_COMMIT_BRANCH' != 'main'"; fi
    - if [ "${CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME}" != "main" ]; then echo "pull request target branch is not 'main'" ; else echo "pull request target branch '$CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME' == 'main'"; fi
    - if [ "${CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME}" == "main" ]; then echo "pull request target branch is 'main'" ; else echo "pull request target branch '$CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME' != 'main'"; fi
    - if [ ! -z "${CI_COMMIT_BRANCH}" -a "${CI_COMMIT_BRANCH}" != "main" ]; then echo "commit branch is neither null nor 'main', it's actually $CI_COMMIT_BRANCH" ; else echo "commit branch '$CI_COMMIT_BRANCH' == 'main'"; fi
    - if [ ! -z "${CI_COMMIT_BRANCH}" -a "${CI_COMMIT_BRANCH}" == "main" ]; then echo "commit branch should be 'main' and is actually  $CI_COMMIT_BRANCH" ; else echo "commit branch '$CI_COMMIT_BRANCH' != 'main'"; fi
    - if [ ! -z "${CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME}" -a "${CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME}" != "main" ]; then echo "pull request target branch is neither null nor 'main', it's actually $CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME" ; else echo "pull request target branch '$CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME' == 'main'"; fi
    - if [ ! -z "${CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME}" -a "${CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME}" == "main" ]; then echo "pull request target branch should be 'main' and is actually  $CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME" ; else echo "pull request target branch '$CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME' != 'main'"; fi
    - if [ "${CI_COMMIT_BRANCH}" != "main" -a "${CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME}" != "main" ]; then echo "possible commit branch and possible pull request target branch are not 'main'" ; else echo "commit branch '$CI_COMMIT_BRANCH' == 'main' || pull request target branch '$CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME' == 'main'"; fi
    - if [ "${CI_COMMIT_BRANCH}" == "main" -o "${CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME}" == "main" ]; then echo "commit branch or pull request target branch is 'main'" ; else echo "commit branch '$CI_COMMIT_BRANCH' != 'main' && pull request target branch '$CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME' != 'main'"; fi
    - if [ "${CI_PIPELINE_SOURCE}" != "external_pull_request_event" ]; then echo "ci pipeline source is not 'external_pull_request_event'" ; else echo "ci pipeline source '$CI_PIPELINE_SOURCE' == 'external_pull_request_event'"; fi
    - if [ "${CI_PIPELINE_SOURCE}" == "external_pull_request_event" ]; then echo "ci pipeline source is 'external_pull_request_event'" ; else echo "ci pipeline source '$CI_PIPELINE_SOURCE' != 'external_pull_request_event'"; fi
    - if [[ $CI_COMMIT_TAG =~ $PRERELEASE_REGEX ]]; then echo "$CI_COMMIT_TAG is a valid pre-release tag."; else echo "$CI_COMMIT_TAG is not a valid pre-release tag!"; fi
    - if [[ $CI_COMMIT_TAG =~ $RELEASE_REGEX ]]; then echo "$CI_COMMIT_TAG is a valid release tag."; else echo "$CI_COMMIT_TAG is not a valid release tag!"; fi

check-release-rules:
  stage: .pre
  interruptible: true
  allow_failure: true
  rules:
    - if: $CI_COMMIT_BRANCH && $CI_COMMIT_BRANCH == "main" || $CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME == "main"
    - if: $CI_COMMIT_TAG =~ /^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(alpha|beta|rc)(?:[1-9]\d*)?))?$/
  before_script:
    - PRERELEASE_REGEX="^(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)-((alpha|beta|rc)([1-9][0-9]*)?)$"
    - RELEASE_REGEX="^(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)$"
  script:
    - echo $CI_COMMIT_BRANCH
    - echo $CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME
    - echo $CI_COMMIT_TAG
    - if [ "${CI_COMMIT_BRANCH}" != "main" ]; then echo "commit branch is not 'main'" ; else echo "commit branch '$CI_COMMIT_BRANCH' == 'main'"; fi
    - if [ "${CI_COMMIT_BRANCH}" == "main" ]; then echo "commit branch is 'main'" ; else echo "commit branch '$CI_COMMIT_BRANCH' != 'main'"; fi
    - if [ "${CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME}" != "main" ]; then echo "pull request target branch is not 'main'" ; else echo "pull request target branch '$CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME' == 'main'"; fi
    - if [ "${CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME}" == "main" ]; then echo "pull request target branch is 'main'" ; else echo "pull request target branch '$CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME' != 'main'"; fi
    - if [ ! -z "${CI_COMMIT_BRANCH}" -a "${CI_COMMIT_BRANCH}" != "main" ]; then echo "commit branch is neither null nor 'main', it's actually $CI_COMMIT_BRANCH" ; else echo "commit branch '$CI_COMMIT_BRANCH' == 'main'"; fi
    - if [ ! -z "${CI_COMMIT_BRANCH}" -a "${CI_COMMIT_BRANCH}" == "main" ]; then echo "commit branch should be 'main' and is actually  $CI_COMMIT_BRANCH" ; else echo "commit branch '$CI_COMMIT_BRANCH' != 'main'"; fi
    - if [ ! -z "${CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME}" -a "${CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME}" != "main" ]; then echo "pull request target branch is neither null nor 'main', it's actually $CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME" ; else echo "pull request target branch '$CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME' == 'main'"; fi
    - if [ ! -z "${CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME}" -a "${CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME}" == "main" ]; then echo "pull request target branch should be 'main' and is actually  $CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME" ; else echo "pull request target branch '$CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME' != 'main'"; fi
    - if [ "${CI_COMMIT_BRANCH}" != "main" -a "${CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME}" != "main" ]; then echo "possible commit branch and possible pull request target branch are not 'main'" ; else echo "commit branch '$CI_COMMIT_BRANCH' == 'main' || pull request target branch '$CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME' == 'main'"; fi
    - if [ "${CI_COMMIT_BRANCH}" == "main" -o "${CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME}" == "main" ]; then echo "commit branch or pull request target branch is 'main'" ; else echo "commit branch '$CI_COMMIT_BRANCH' != 'main' && pull request target branch '$CI_EXTERNAL_PULL_REQUEST_TARGET_BRANCH_NAME' != 'main'"; fi
    - if [ "${CI_PIPELINE_SOURCE}" != "external_pull_request_event" ]; then echo "ci pipeline source is not 'external_pull_request_event'" ; else echo "ci pipeline source '$CI_PIPELINE_SOURCE' == 'external_pull_request_event'"; fi
    - if [ "${CI_PIPELINE_SOURCE}" == "external_pull_request_event" ]; then echo "ci pipeline source is 'external_pull_request_event'" ; else echo "ci pipeline source '$CI_PIPELINE_SOURCE' != 'external_pull_request_event'"; fi
    - if [[ $CI_COMMIT_TAG =~ $PRERELEASE_REGEX ]]; then echo "$CI_COMMIT_TAG is a valid pre-release tag."; else echo "$CI_COMMIT_TAG is not a valid pre-release tag!"; fi
    - if [[ $CI_COMMIT_TAG =~ $RELEASE_REGEX ]]; then echo "$CI_COMMIT_TAG is a valid release tag."; else echo "$CI_COMMIT_TAG is not a valid release tag!"; fi


#############################################################################
## NON MAIN COMMITS OR MAIN TARGETED PULL REQUESTS, NON (PRE-)RELEASE TAGS
#############################################################################

install-dependencies:
  stage: build
  interruptible: true
  rules:
    - !reference [ .default_rules, rules ]
    - !reference [ .development_rules, rules ]
  cache:
    key:
      files:
        - package-lock.json
    paths:
      - node_modules
      - .npm/
      - cache/Cypress
  script:
    - npm ci --cache .npm --prefer-offline --no-fund
  artifacts:
    paths:
      - node_modules
      - cache/Cypress

.distributed:
  interruptible: true
  rules:
    - !reference [.default_rules, rules]
  needs:
    - install-dependencies
  artifacts:
    paths:
      - node_modules/.cache/nx
      - cache/Cypress

build-db-image:
  stage: build
  rules:
    - !reference [ .default_db_rules, rules ]
    - !reference [ .development_db_rules, rules ]
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - echo "$REGISTRY_PASSWORD" | docker login -u $REGISTRY_USER --password-stdin $REGISTRY
  script:
    - docker build -f database/Postgres.Dockerfile -t ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-db:${CI_COMMIT_SHA} -t ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-db:latest .
    - docker push -q -a ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-db
  after_script:
    - docker logout $REGISTRY

build-liquibase-image:
  stage: build
  rules:
    - !reference [ .default_db_rules, rules ]
    - !reference [ .development_db_rules, rules ]
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - echo "$REGISTRY_PASSWORD" | docker login -u $REGISTRY_USER --password-stdin $REGISTRY
  script:
    - docker build -f database/Liquibase.Dockerfile -t ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-liquibase:${CI_COMMIT_SHA} -t ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-liquibase:latest .
    - docker push -q -a ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-liquibase
  after_script:
    - docker logout $REGISTRY

patch-db-image:
  stage: build
  rules:
    - !reference [ .default_db_rules, rules ]
  needs:
    - build-db-image
    - build-liquibase-image
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - sed -i "s/TAG=.*$/TAG=${CI_COMMIT_SHA}/" .env.dev
    - docker compose --env-file .env.dev pull -q db liquibase
    - docker compose --env-file .env.dev up -d db
    - export $(grep -v '^#' .env.dev | xargs)
    - docker compose --env-file .env.dev run --rm liquibase liquibase --changelogFile=studio-lite.changelog-root.xml --url=jdbc:postgresql://db:5432/${POSTGRES_DB} --username=${POSTGRES_USER} --password=${POSTGRES_PASSWORD} --classpath=changelog status
    - docker compose --env-file .env.dev run --rm liquibase liquibase --changelogFile=studio-lite.changelog-root.xml --url=jdbc:postgresql://db:5432/${POSTGRES_DB} --username=${POSTGRES_USER} --password=${POSTGRES_PASSWORD} --classpath=changelog validate
    - docker compose --env-file .env.dev run --rm liquibase liquibase --changelogFile=studio-lite.changelog-root.xml --url=jdbc:postgresql://db:5432/${POSTGRES_DB} --username=${POSTGRES_USER} --password=${POSTGRES_PASSWORD} --classpath=changelog updateSQL
  script:
    - docker compose --env-file .env.dev run --rm liquibase liquibase --changelogFile=studio-lite.changelog-root.xml --url=jdbc:postgresql://db:5432/${POSTGRES_DB} --username=${POSTGRES_USER} --password=${POSTGRES_PASSWORD} --classpath=changelog updateTestingRollback
    - docker compose --env-file .env.dev run --rm liquibase liquibase --changelogFile=studio-lite.changelog-root.xml --url=jdbc:postgresql://db:5432/${POSTGRES_DB} --username=${POSTGRES_USER} --password=${POSTGRES_PASSWORD} --classpath=changelog history

build-app:
  stage: build
  extends: .distributed
  rules:
    - !reference [ .default_rules, rules ]

  script:
    - apt-get update && apt-get install -y --no-install-recommends git && rm -rf /var/lib/apt/lists/*
    - npx nx affected --base=HEAD~1 --target=build --parallel=3
  artifacts:
    paths:
      - dist

test-app:
  stage: unit-test
  allow_failure: true
  extends: .distributed
  rules:
    - !reference [ .default_rules, rules ]
  script:
    - apt-get update && apt-get install -y --no-install-recommends git && rm -rf /var/lib/apt/lists/*
    - npx nx affected --base=HEAD~1 --target=test --parallel=2

test-app-e2e:
  stage: e2e-test
  allow_failure: true
  extends: .distributed
  rules:
    - !reference [ .default_rules, rules ]
  variables:
    DOCKER_HOST: tcp://docker:2375
  image: $CYPRESS_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - curl -fsSL https://get.docker.com -o get-docker.sh && sh ./get-docker.sh
    - sed -i "s/TAG=.*$/TAG=latest/" .env.dev
    - sed -i "s^REGISTRY_PATH=.*$^REGISTRY_PATH=${CI_REGISTRY_IMAGE}/^" .env.dev
    - docker compose --env-file .env.dev up -d --quiet-pull db
    - docker compose --env-file .env.dev up --quiet-pull liquibase
    - $(npm bin)/cypress cache path # show where the Cypress test runner binaries are cached
    - $(npm bin)/cypress cache list # show all installed versions of Cypress binary
    - $(npm bin)/cypress verify
    - export POSTGRES_HOST=docker
  script:
    - npx nx serve api --verbose --watch=false & # start backend
    - npx nx e2e frontend-e2e --prod --browser chrome --spec "./apps/frontend-e2e/src/integration/api/*" || ( pkill npx && exit 1 )

test-app-e2e-ui-chrome:
  stage: e2e-test
  allow_failure: true
  extends: .distributed
  rules:
    - !reference [ .default_rules, rules ]
  variables:
    DOCKER_HOST: tcp://docker:2375
  image: $CYPRESS_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - curl -fsSL https://get.docker.com -o get-docker.sh && sh ./get-docker.sh
    - sed -i "s/TAG=.*$/TAG=latest/" .env.dev
    - sed -i "s^REGISTRY_PATH=.*$^REGISTRY_PATH=${CI_REGISTRY_IMAGE}/^" .env.dev
    - docker compose --env-file .env.dev up -d --quiet-pull db
    - docker compose --env-file .env.dev up --quiet-pull liquibase
    - $(npm bin)/cypress cache path # show where the Cypress test runner binaries are cached
    - $(npm bin)/cypress cache list # show all installed versions of Cypress binary
    - $(npm bin)/cypress verify
    - export POSTGRES_HOST=docker
  script:
    - npx nx serve api --watch=false & # start backend
    - npx nx e2e frontend-e2e --prod --browser chrome --spec "./apps/frontend-e2e/src/integration/ui/*" || ( pkill npx && exit 1 )

test-app-e2e-ui-chrome-mobile:
  stage: e2e-test
  allow_failure: true
  extends: .distributed
  rules:
    - !reference [ .default_manual_rules, rules ]
  variables:
    DOCKER_HOST: tcp://docker:2375
  image: $CYPRESS_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - curl -fsSL https://get.docker.com -o get-docker.sh && sh ./get-docker.sh
    - sed -i "s/TAG=.*$/TAG=latest/" .env.dev
    - sed -i "s^REGISTRY_PATH=.*$^REGISTRY_PATH=${CI_REGISTRY_IMAGE}/^" .env.dev
    - docker compose --env-file .env.dev up -d --quiet-pull db
    - docker compose --env-file .env.dev up --quiet-pull liquibase
    - $(npm bin)/cypress cache path # show where the Cypress test runner binaries are cached
    - $(npm bin)/cypress cache list # show all installed versions of Cypress binary
    - $(npm bin)/cypress verify
    - export POSTGRES_HOST=docker
  script:
    - npx nx serve api --watch=false & # start backend
    - npx nx e2e frontend-e2e --prod --browser chrome --spec "./apps/frontend-e2e/src/integration/ui/*" --config "viewportWidth=375,viewportHeight=667" || ( pkill npx && exit 1 )

test-app-e2e-ui-firefox:
  stage: e2e-test
  allow_failure: true
  extends: .distributed
  rules:
    - !reference [ .default_manual_rules, rules ]
  variables:
    DOCKER_HOST: tcp://docker:2375
  image: $CYPRESS_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - curl -fsSL https://get.docker.com -o get-docker.sh && sh ./get-docker.sh
    - sed -i "s/TAG=.*$/TAG=latest/" .env.dev
    - sed -i "s^REGISTRY_PATH=.*$^REGISTRY_PATH=${CI_REGISTRY_IMAGE}/^" .env.dev
    - docker compose --env-file .env.dev up -d --quiet-pull db
    - docker compose --env-file .env.dev up --quiet-pull liquibase
    - $(npm bin)/cypress cache path # show where the Cypress test runner binaries are cached
    - $(npm bin)/cypress cache list # show all installed versions of Cypress binary
    - $(npm bin)/cypress verify
    - export POSTGRES_HOST=docker
  script:
    - npx nx serve api --watch=false & # start backend
    - npx nx e2e frontend-e2e --prod --browser firefox --spec "./apps/frontend-e2e/src/integration/ui/*" || ( pkill npx && exit 1 )

test-app-e2e-ui-firefox-mobile:
  stage: e2e-test
  allow_failure: true
  extends: .distributed
  rules:
    - !reference [ .default_manual_rules, rules ]
  variables:
    DOCKER_HOST: tcp://docker:2375
  image: $CYPRESS_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - curl -fsSL https://get.docker.com -o get-docker.sh && sh ./get-docker.sh
    - sed -i "s/TAG=.*$/TAG=latest/" .env.dev
    - sed -i "s^REGISTRY_PATH=.*$^REGISTRY_PATH=${CI_REGISTRY_IMAGE}/^" .env.dev
    - docker compose --env-file .env.dev up -d --quiet-pull db
    - docker compose --env-file .env.dev up --quiet-pull liquibase
    - $(npm bin)/cypress cache path # show where the Cypress test runner binaries are cached
    - $(npm bin)/cypress cache list # show all installed versions of Cypress binary
    - $(npm bin)/cypress verify
    - export POSTGRES_HOST=docker
  script:
    - npx nx serve api --watch=false & # start backend
    - npx nx e2e frontend-e2e --prod --browser firefox --spec "./apps/frontend-e2e/src/integration/ui/*" --config "viewportWidth=375,viewportHeight=667" || ( pkill npx && exit 1 )

test-app-e2e-ui-edge:
  stage: e2e-test
  allow_failure: true
  extends: .distributed
  rules:
    - !reference [ .default_manual_rules, rules ]
  variables:
    DOCKER_HOST: tcp://docker:2375
  image: $CYPRESS_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - curl -fsSL https://get.docker.com -o get-docker.sh && sh ./get-docker.sh
    - sed -i "s/TAG=.*$/TAG=latest/" .env.dev
    - sed -i "s^REGISTRY_PATH=.*$^REGISTRY_PATH=${CI_REGISTRY_IMAGE}/^" .env.dev
    - docker compose --env-file .env.dev up -d --quiet-pull db
    - docker compose --env-file .env.dev up --quiet-pull liquibase
    - $(npm bin)/cypress cache path # show where the Cypress test runner binaries are cached
    - $(npm bin)/cypress cache list # show all installed versions of Cypress binary
    - $(npm bin)/cypress verify
    - export POSTGRES_HOST=docker
  script:
    - npx nx serve api --watch=false & # start backend
    - npx nx e2e frontend-e2e --prod --browser edge --spec "./apps/frontend-e2e/src/integration/ui/*" || ( pkill npx && exit 1 )

test-app-e2e-ui-edge-mobile:
  stage: e2e-test
  allow_failure: true
  extends: .distributed
  rules:
    - !reference [ .default_manual_rules, rules ]
  variables:
    DOCKER_HOST: tcp://docker:2375
  image: $CYPRESS_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - curl -fsSL https://get.docker.com -o get-docker.sh && sh ./get-docker.sh
    - sed -i "s/TAG=.*$/TAG=latest/" .env.dev
    - sed -i "s^REGISTRY_PATH=.*$^REGISTRY_PATH=${CI_REGISTRY_IMAGE}/^" .env.dev
    - docker compose --env-file .env.dev up -d --quiet-pull db
    - docker compose --env-file .env.dev up --quiet-pull liquibase
    - $(npm bin)/cypress cache path # show where the Cypress test runner binaries are cached
    - $(npm bin)/cypress cache list # show all installed versions of Cypress binary
    - $(npm bin)/cypress verify
    - export POSTGRES_HOST=docker
  script:
    - npx nx serve api --watch=false & # start backend
    - npx nx e2e frontend-e2e --prod --browser edge --spec "./apps/frontend-e2e/src/integration/ui/*" --config "viewportWidth=375,viewportHeight=667" || ( pkill npx && exit 1 )

lint-app:
  stage: lint
  extends: .distributed
  allow_failure: true
  rules:
    - !reference [ .default_rules, rules ]
  script:
    - apt-get update && apt-get install -y --no-install-recommends git && rm -rf /var/lib/apt/lists/*
    - npx nx affected --base=HEAD~1 --target=lint --parallel=2

audit-app:
  stage: audit
  allow_failure: true
  rules:
    - !reference [ .default_rules, rules ]
  script:
    - npm audit --audit-level critical

scan-docker-db:
  stage: scan-images
  allow_failure: true
  rules:
    - !reference [ .development_db_rules, rules ]
  needs:
    - build-db-image
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  script:
    - docker pull -q ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-db:${CI_COMMIT_SHA}
    - docker run --rm -v /var/run/docker.sock:/var/run/docker.sock -v $HOME/Library/Caches:/root/.cache/ aquasec/trivy:0.29.2 image --exit-code 1 --security-checks vuln --ignore-unfixed --severity CRITICAL ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-db:${CI_COMMIT_SHA}

scan-docker-liquibase:
  stage: scan-images
  allow_failure: true
  rules:
    - !reference [ .development_db_rules, rules ]
  needs:
    - build-liquibase-image
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  script:
    - docker pull -q ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-liquibase:${CI_COMMIT_SHA}
    - docker run --rm -v /var/run/docker.sock:/var/run/docker.sock -v $HOME/Library/Caches:/root/.cache/ aquasec/trivy:0.29.2 image --exit-code 1 --security-checks vuln --ignore-unfixed --severity CRITICAL ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-liquibase:${CI_COMMIT_SHA}

build-docker-app:
  stage: build-images
  extends: .distributed
  rules:
    - !reference [ .development_rules, rules ]
  needs:
    - install-dependencies
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - apk add --no-cache npm
    - npm i -g npx
    - echo "$REGISTRY_PASSWORD" | docker login -u $REGISTRY_USER --password-stdin $REGISTRY
  script:
    - npx nx affected --base=HEAD~1 --target=docker-build --registry=$REGISTRY --registryProject=$REGISTRY_PROJECT --tag=${CI_COMMIT_SHA} --parallel=2
  after_script:
    - docker logout $REGISTRY

scan-docker-app:
  stage: scan-images
  allow_failure: true
  extends: .distributed
  rules:
    - !reference [ .development_rules, rules ]
  needs:
    - install-dependencies
    - build-docker-app
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - apk add --no-cache npm
    - npm i -g npx
  script:
    - npx nx affected --base=HEAD~1 --target=docker-scan --registry=$REGISTRY --registryProject=$REGISTRY_PROJECT --tag=${CI_COMMIT_SHA}


#############################################################################
## MAIN COMMITS, (PRE-)RELEASE TAGS, OR PULL REQUESTS WITH TARGET MAIN
#############################################################################

build-backend-test-image:
  stage: build
  rules:
    - !reference [ .prepare_release_rules, rules ]
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - docker build -f apps/api/Dockerfile --build-arg project=api --target=dev -t ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-backend:${CI_COMMIT_SHA}_test .
    - docker push ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-backend:${CI_COMMIT_SHA}_test
  after_script:
    - docker logout $CI_REGISTRY

build-frontend-test-image:
  stage: build
  rules:
    - !reference [ .prepare_release_rules, rules ]
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - docker build -f apps/frontend/Dockerfile --build-arg project=frontend --build-arg apihost=studio-lite-backend --build-arg apiport=3333 --target=dev -t ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-frontend:${CI_COMMIT_SHA}_test .
    - docker push ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-frontend:${CI_COMMIT_SHA}_test
  after_script:
    - docker logout $CI_REGISTRY

build-frontend-e2e-test-image:
  stage: build
  rules:
    - !reference [ .prepare_release_rules, rules ]
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - docker build -f apps/frontend-e2e/Dockerfile -t ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-frontend-e2e:${CI_COMMIT_SHA} -t ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-frontend-e2e:latest .
    - docker push -a ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-frontend-e2e
  after_script:
    - docker logout $CI_REGISTRY

build-db-release-image:
  stage: build
  rules:
    - !reference [ .prepare_release_rules, rules ]
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - docker build -f database/Postgres.Dockerfile -t ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-db:${CI_COMMIT_SHA} .
    - docker push -q ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-db:${CI_COMMIT_SHA}
  after_script:
    - docker logout $CI_REGISTRY

build-liquibase-release-image:
  stage: build
  rules:
    - !reference [ .prepare_release_rules, rules ]
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - echo "$REGISTRY_PASSWORD" | docker login -u $REGISTRY_USER --password-stdin $REGISTRY
  script:
    - docker build -f database/Liquibase.Dockerfile -t ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-liquibase:${CI_COMMIT_SHA} .
    - docker push -q ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-liquibase:${CI_COMMIT_SHA}
  after_script:
    - docker logout $REGISTRY

patch-db-release-image:
  stage: build
  rules:
    - !reference [ .prepare_release_rules, rules ]
  needs:
    - build-db-release-image
    - build-liquibase-release-image
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - sed -i "s/TAG=.*$/TAG=${CI_COMMIT_SHA}/" .env.prod.template
    - sed -i "s^REGISTRY_PATH=.*$^REGISTRY_PATH=${CI_REGISTRY_IMAGE}/^" .env.prod.template
    - docker compose --env-file .env.prod.template -f docker-compose.yml -f docker-compose.prod.yml pull -q db liquibase
    - docker compose --env-file .env.prod.template -f docker-compose.yml -f docker-compose.prod.yml up -d db
    - export $(grep -v '^#' .env.prod.template | xargs)
    - docker compose --env-file .env.prod.template -f docker-compose.yml -f docker-compose.prod.yml run --rm liquibase liquibase --changelogFile=studio-lite.changelog-root.xml --url=jdbc:postgresql://db:5432/${POSTGRES_DB} --username=${POSTGRES_USER} --password=${POSTGRES_PASSWORD} --classpath=changelog status
    - docker compose --env-file .env.prod.template -f docker-compose.yml -f docker-compose.prod.yml run --rm liquibase liquibase --changelogFile=studio-lite.changelog-root.xml --url=jdbc:postgresql://db:5432/${POSTGRES_DB} --username=${POSTGRES_USER} --password=${POSTGRES_PASSWORD} --classpath=changelog validate
    - docker compose --env-file .env.prod.template -f docker-compose.yml -f docker-compose.prod.yml run --rm liquibase liquibase --changelogFile=studio-lite.changelog-root.xml --url=jdbc:postgresql://db:5432/${POSTGRES_DB} --username=${POSTGRES_USER} --password=${POSTGRES_PASSWORD} --classpath=changelog updateSQL
  script:
    - docker compose --env-file .env.prod.template -f docker-compose.yml -f docker-compose.prod.yml run --rm liquibase liquibase --changelogFile=studio-lite.changelog-root.xml --url=jdbc:postgresql://db:5432/${POSTGRES_DB} --username=${POSTGRES_USER} --password=${POSTGRES_PASSWORD} --classpath=changelog updateTestingRollback
    - docker compose --env-file .env.prod.template -f docker-compose.yml -f docker-compose.prod.yml run --rm liquibase liquibase --changelogFile=studio-lite.changelog-root.xml --url=jdbc:postgresql://db:5432/${POSTGRES_DB} --username=${POSTGRES_USER} --password=${POSTGRES_PASSWORD} --classpath=changelog history

build-backend-release-image:
  stage: build
  rules:
    - !reference [ .prepare_release_rules, rules ]
  needs:
    - build-backend-test-image
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
    - docker pull -q ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-backend:${CI_COMMIT_SHA}_test
  script:
    - docker build --cache-from ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-backend:${CI_COMMIT_SHA}_test -f apps/api/Dockerfile --build-arg project=api --target=prod -t ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-backend:${CI_COMMIT_SHA} .
    - docker push ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-backend:${CI_COMMIT_SHA}
  after_script:
    - docker logout $CI_REGISTRY

build-frontend-release-image:
  stage: build
  rules:
    - !reference [ .prepare_release_rules, rules ]
  needs:
    - build-frontend-test-image
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
    - docker pull -q ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-frontend:${CI_COMMIT_SHA}_test
  script:
    - docker build --cache-from ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-frontend:${CI_COMMIT_SHA}_test -f apps/frontend/Dockerfile --build-arg project=frontend --target=prod -t ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-frontend:${CI_COMMIT_SHA} .
    - docker push ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-frontend:${CI_COMMIT_SHA}
  after_script:
    - docker logout $CI_REGISTRY

test-backend:
  stage: unit-test
  allow_failure: true
  rules:
    - !reference [ .prepare_release_rules, rules ]
  needs:
    - build-backend-test-image
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - docker pull -q ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-backend:${CI_COMMIT_SHA}_test
  script:
    - docker run ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-backend:${CI_COMMIT_SHA}_test test api

test-frontend:
  stage: unit-test
  allow_failure: true
  rules:
    - !reference [ .prepare_release_rules, rules ]
  needs:
    - build-frontend-test-image
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - docker pull -q ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-frontend:${CI_COMMIT_SHA}_test
  script:
    - docker run ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-frontend:${CI_COMMIT_SHA}_test test frontend

test-release-e2e:
  stage: e2e-test
  allow_failure: true
  rules:
    - !reference [ .prepare_release_rules, rules ]
  needs:
    - patch-db-release-image
    - build-backend-release-image
    - build-frontend-release-image
    - build-frontend-e2e-test-image
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - sed -i "s/TAG=.*$/TAG=${CI_COMMIT_SHA}/" .env.prod.template
    - sed -i "s^REGISTRY_PATH=.*$^REGISTRY_PATH=${CI_REGISTRY_IMAGE}/^" .env.prod.template
    - export $(grep -v '^#' .env.prod.template | xargs)
    - cp config/frontend/default.conf.http-template config/frontend/default.conf.template
  script:
    - docker compose --env-file .env.prod.template -f docker-compose.yml -f docker-compose.prod.yml up -d --quiet-pull
    - docker compose --env-file .env.prod.template -f docker-compose.yml -f docker-compose.prod.yml run --rm liquibase liquibase --changelogFile=studio-lite.changelog-root.xml --url=jdbc:postgresql://db:5432/${POSTGRES_DB} --username=${POSTGRES_USER} --password=${POSTGRES_PASSWORD} --classpath=changelog history
    - docker compose -f docker-compose.e2e.yml up --quiet-pull --exit-code-from test-e2e-api test-e2e-api

test-release-e2e-ui-chrome:
  stage: e2e-test
  allow_failure: true
  rules:
    - !reference [ .prepare_release_rules, rules ]
  needs:
    - patch-db-release-image
    - build-backend-release-image
    - build-frontend-release-image
    - build-frontend-e2e-test-image
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - sed -i "s/TAG=.*$/TAG=${CI_COMMIT_SHA}/" .env.prod.template
    - sed -i "s^REGISTRY_PATH=.*$^REGISTRY_PATH=${CI_REGISTRY_IMAGE}/^" .env.prod.template
    - export $(grep -v '^#' .env.prod.template | xargs)
    - cp config/frontend/default.conf.http-template config/frontend/default.conf.template
  script:
    - docker compose --env-file .env.prod.template -f docker-compose.yml -f docker-compose.prod.yml up -d --quiet-pull
    - docker compose --env-file .env.prod.template -f docker-compose.yml -f docker-compose.prod.yml run --rm liquibase liquibase --changelogFile=studio-lite.changelog-root.xml --url=jdbc:postgresql://db:5432/${POSTGRES_DB} --username=${POSTGRES_USER} --password=${POSTGRES_PASSWORD} --classpath=changelog history
    - docker compose -f docker-compose.e2e.yml up --quiet-pull --exit-code-from test-e2e-ui-chrome test-e2e-ui-chrome

test-release-e2e-ui-chrome-mobile:
  stage: e2e-test
  allow_failure: true
  rules:
    - !reference [ .prepare_release_manual_rules, rules ]
  needs:
    - patch-db-release-image
    - build-backend-release-image
    - build-frontend-release-image
    - build-frontend-e2e-test-image
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - sed -i "s/TAG=.*$/TAG=${CI_COMMIT_SHA}/" .env.prod.template
    - sed -i "s^REGISTRY_PATH=.*$^REGISTRY_PATH=${CI_REGISTRY_IMAGE}/^" .env.prod.template
    - export $(grep -v '^#' .env.prod.template | xargs)
    - cp config/frontend/default.conf.http-template config/frontend/default.conf.template
  script:
    - docker compose --env-file .env.prod.template -f docker-compose.yml -f docker-compose.prod.yml up -d --quiet-pull
    - docker compose --env-file .env.prod.template -f docker-compose.yml -f docker-compose.prod.yml run --rm liquibase liquibase --changelogFile=studio-lite.changelog-root.xml --url=jdbc:postgresql://db:5432/${POSTGRES_DB} --username=${POSTGRES_USER} --password=${POSTGRES_PASSWORD} --classpath=changelog history
    - docker compose -f docker-compose.e2e.yml up --quiet-pull --exit-code-from test-e2e-ui-chrome-mobile test-e2e-ui-chrome-mobile

test-release-e2e-ui-firefox:
  stage: e2e-test
  allow_failure: true
  rules:
    - !reference [ .prepare_release_manual_rules, rules ]
  needs:
    - patch-db-release-image
    - build-backend-release-image
    - build-frontend-release-image
    - build-frontend-e2e-test-image
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - sed -i "s/TAG=.*$/TAG=${CI_COMMIT_SHA}/" .env.prod.template
    - sed -i "s^REGISTRY_PATH=.*$^REGISTRY_PATH=${CI_REGISTRY_IMAGE}/^" .env.prod.template
    - export $(grep -v '^#' .env.prod.template | xargs)
    - cp config/frontend/default.conf.http-template config/frontend/default.conf.template
  script:
    - docker compose --env-file .env.prod.template -f docker-compose.yml -f docker-compose.prod.yml up -d --quiet-pull
    - docker compose --env-file .env.prod.template -f docker-compose.yml -f docker-compose.prod.yml run --rm liquibase liquibase --changelogFile=studio-lite.changelog-root.xml --url=jdbc:postgresql://db:5432/${POSTGRES_DB} --username=${POSTGRES_USER} --password=${POSTGRES_PASSWORD} --classpath=changelog history
    - docker compose -f docker-compose.e2e.yml up --quiet-pull --exit-code-from test-e2e-ui-firefox test-e2e-ui-firefox

test-release-e2e-ui-firefox-mobile:
  stage: e2e-test
  allow_failure: true
  rules:
    - !reference [ .prepare_release_manual_rules, rules ]
  needs:
    - patch-db-release-image
    - build-backend-release-image
    - build-frontend-release-image
    - build-frontend-e2e-test-image
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - sed -i "s/TAG=.*$/TAG=${CI_COMMIT_SHA}/" .env.prod
    - sed -i "s^REGISTRY_PATH=.*$^REGISTRY_PATH=${CI_REGISTRY_IMAGE}/^" .env.prod
    - export $(grep -v '^#' .env.prod | xargs)
    - cp config/frontend/default.conf.http-template config/frontend/default.conf.template
  script:
    - docker compose --env-file .env.prod -f docker-compose.yml -f docker-compose.prod.yml up -d --quiet-pull
    - docker compose --env-file .env.prod -f docker-compose.yml -f docker-compose.prod.yml run --rm liquibase liquibase --changelogFile=studio-lite.changelog-root.xml --url=jdbc:postgresql://db:5432/${POSTGRES_DB} --username=${POSTGRES_USER} --password=${POSTGRES_PASSWORD} --classpath=changelog history
    - docker compose -f docker-compose.e2e.yml up --quiet-pull --exit-code-from test-e2e-ui-firefox-mobile test-e2e-ui-firefox-mobile

test-release-e2e-ui-edge:
  stage: e2e-test
  allow_failure: true
  rules:
    - !reference [ .prepare_release_manual_rules, rules ]
  needs:
    - patch-db-release-image
    - build-backend-release-image
    - build-frontend-release-image
    - build-frontend-e2e-test-image
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - sed -i "s/TAG=.*$/TAG=${CI_COMMIT_SHA}/" .env.prod
    - sed -i "s^REGISTRY_PATH=.*$^REGISTRY_PATH=${CI_REGISTRY_IMAGE}/^" .env.prod
    - export $(grep -v '^#' .env.prod | xargs)
    - cp config/frontend/default.conf.http-template config/frontend/default.conf.template
  script:
    - docker compose --env-file .env.prod -f docker-compose.yml -f docker-compose.prod.yml up -d --quiet-pull
    - docker compose --env-file .env.prod -f docker-compose.yml -f docker-compose.prod.yml run --rm liquibase liquibase --changelogFile=studio-lite.changelog-root.xml --url=jdbc:postgresql://db:5432/${POSTGRES_DB} --username=${POSTGRES_USER} --password=${POSTGRES_PASSWORD} --classpath=changelog history
    - docker compose -f docker-compose.e2e.yml up --quiet-pull --exit-code-from test-e2e-ui-edge test-e2e-ui-edge

test-release-e2e-ui-edge-mobile:
  stage: e2e-test
  allow_failure: true
  rules:
    - !reference [ .prepare_release_manual_rules, rules ]
  needs:
    - patch-db-release-image
    - build-backend-release-image
    - build-frontend-release-image
    - build-frontend-e2e-test-image
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - sed -i "s/TAG=.*$/TAG=${CI_COMMIT_SHA}/" .env.prod
    - sed -i "s^REGISTRY_PATH=.*$^REGISTRY_PATH=${CI_REGISTRY_IMAGE}/^" .env.prod
    - export $(grep -v '^#' .env.prod | xargs)
    - cp config/frontend/default.conf.http-template config/frontend/default.conf.template
  script:
    - docker compose --env-file .env.prod -f docker-compose.yml -f docker-compose.prod.yml up -d --quiet-pull
    - docker compose --env-file .env.prod -f docker-compose.yml -f docker-compose.prod.yml run --rm liquibase liquibase --changelogFile=studio-lite.changelog-root.xml --url=jdbc:postgresql://db:5432/${POSTGRES_DB} --username=${POSTGRES_USER} --password=${POSTGRES_PASSWORD} --classpath=changelog history
    - docker compose -f docker-compose.e2e.yml up --quiet-pull --exit-code-from test-e2e-ui-edge-mobile test-e2e-ui-edge-mobile

lint-backend:
  stage: lint
  allow_failure: true
  rules:
    - !reference [ .prepare_release_rules, rules ]
  needs:
    - build-backend-test-image
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - docker pull ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-backend:${CI_COMMIT_SHA}_test
  script:
    - docker run ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-backend:${CI_COMMIT_SHA}_test lint api

lint-frontend:
  stage: lint
  allow_failure: true
  rules:
    - !reference [ .prepare_release_rules, rules ]
  needs:
    - build-frontend-test-image
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - docker pull ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-frontend:${CI_COMMIT_SHA}_test
  script:
    - docker run ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-frontend:${CI_COMMIT_SHA}_test lint frontend

lint-frontend-e2e:
  stage: lint
  allow_failure: true
  rules:
    - !reference [ .prepare_release_rules, rules ]
  needs:
    - build-frontend-e2e-test-image
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - docker pull ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-frontend-e2e:${CI_COMMIT_SHA}
  script:
    - docker run ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-frontend-e2e:${CI_COMMIT_SHA} lint frontend-e2e

audit-backend:
  stage: audit
  rules:
    - !reference [ .prepare_release_rules, rules ]
  needs:
    - build-backend-test-image
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - docker pull ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-backend:${CI_COMMIT_SHA}_test
  script:
    - docker run --entrypoint npm ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-backend:${CI_COMMIT_SHA}_test audit --audit-level critical

audit-frontend:
  stage: audit
  rules:
    - !reference [ .prepare_release_rules, rules ]
  needs:
    - build-frontend-test-image
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - docker pull ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-frontend:${CI_COMMIT_SHA}_test
  script:
    - docker run --entrypoint npm ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-frontend:${CI_COMMIT_SHA}_test audit --audit-level critical

scan-release-db:
  stage: scan-images
  allow_failure: true
  rules:
    - !reference [ .build_release_rules, rules ]
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
    - docker pull -q ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-db:${CI_COMMIT_BEFORE_SHA}
    - docker pull -q aquasec/trivy:0.29.2
  script:
    - docker run --rm -v /var/run/docker.sock:/var/run/docker.sock -v $HOME/Library/Caches:/root/.cache/ aquasec/trivy:0.29.2 image --exit-code 1 --security-checks vuln --ignore-unfixed --severity CRITICAL ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-db:${CI_COMMIT_BEFORE_SHA}
    - docker tag ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-db:${CI_COMMIT_BEFORE_SHA} ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-db:${CI_COMMIT_SHA}
    - docker push -q ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-db:${CI_COMMIT_SHA}
  after_script:
    - docker logout $CI_REGISTRY

scan-release-liquibase:
  stage: scan-images
  allow_failure: true
  rules:
    - !reference [ .build_release_rules, rules ]
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
    - docker pull -q ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-liquibase:${CI_COMMIT_BEFORE_SHA}
    - docker pull -q aquasec/trivy:0.29.2
  script:
    - docker run --rm -v /var/run/docker.sock:/var/run/docker.sock -v $HOME/Library/Caches:/root/.cache/ aquasec/trivy:0.29.2 image --exit-code 1 --security-checks vuln --ignore-unfixed --severity CRITICAL ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-liquibase:${CI_COMMIT_BEFORE_SHA}
    - docker tag ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-liquibase:${CI_COMMIT_BEFORE_SHA} ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-liquibase:${CI_COMMIT_SHA}
    - docker push -q ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-liquibase:${CI_COMMIT_SHA}
  after_script:
    - docker logout $CI_REGISTRY

scan-release-backend:
  stage: scan-images
  allow_failure: true
  rules:
    - !reference [ .build_release_rules, rules ]
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
    - docker pull -q ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-backend:${CI_COMMIT_BEFORE_SHA}
    - docker pull -q aquasec/trivy:0.29.2
  script:
    - docker run --rm -v /var/run/docker.sock:/var/run/docker.sock -v $HOME/Library/Caches:/root/.cache/ aquasec/trivy:0.29.2 image --exit-code 1 --security-checks vuln --ignore-unfixed --severity CRITICAL ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-backend:${CI_COMMIT_BEFORE_SHA}
    - docker tag ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-backend:${CI_COMMIT_BEFORE_SHA} ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-backend:${CI_COMMIT_SHA}
    - docker push -q ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-backend:${CI_COMMIT_SHA}
  after_script:
    - docker logout $CI_REGISTRY

scan-release-frontend:
  stage: scan-images
  allow_failure: true
  rules:
    - !reference [ .build_release_rules, rules ]
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
    - docker pull -q ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-frontend:${CI_COMMIT_BEFORE_SHA}
    - docker pull -q aquasec/trivy:0.29.2
  script:
    - docker run --rm -v /var/run/docker.sock:/var/run/docker.sock -v $HOME/Library/Caches:/root/.cache/ aquasec/trivy:0.29.2 image --exit-code 1 --security-checks vuln --ignore-unfixed --severity CRITICAL ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-frontend:${CI_COMMIT_BEFORE_SHA}
    - docker tag ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-frontend:${CI_COMMIT_BEFORE_SHA} ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-frontend:${CI_COMMIT_SHA}
    - docker push -q ${CI_REGISTRY_IMAGE}/iqbberlin/studio-lite-frontend:${CI_COMMIT_SHA}
  after_script:
    - docker logout $CI_REGISTRY

push-docker-pre-release:
  stage: push-images
  rules:
    - !reference [ .prerelease_push_rules, rules ]
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - echo "$DOCKERHUB_PASSWORD" | docker login -u $DOCKERHUB_USER --password-stdin
    - docker pull ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-db:${CI_COMMIT_SHA}
    - docker pull ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-liquibase:${CI_COMMIT_SHA}
    - docker pull ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-backend:${CI_COMMIT_SHA}
    - docker pull ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-frontend:${CI_COMMIT_SHA}
  script:
    - docker tag ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-db:${CI_COMMIT_SHA} iqbberlin/studio-lite-db:${CI_COMMIT_TAG}
    - docker tag ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-liquibase:${CI_COMMIT_SHA} iqbberlin/studio-lite-liquibase:${CI_COMMIT_TAG}
    - docker tag ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-backend:${CI_COMMIT_SHA} iqbberlin/studio-lite-backend:${CI_COMMIT_TAG}
    - docker tag ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-frontend:${CI_COMMIT_SHA} iqbberlin/studio-lite-frontend:${CI_COMMIT_TAG}
    - docker push -q iqbberlin/studio-lite-db:${CI_COMMIT_TAG}
    - docker push -q iqbberlin/studio-lite-liquibase:${CI_COMMIT_TAG}
    - docker push -q iqbberlin/studio-lite-backend:${CI_COMMIT_TAG}
    - docker push -q iqbberlin/studio-lite-frontend:${CI_COMMIT_TAG}
  after_script:
    - docker logout

push-docker-release:
  stage: push-images
  rules:
    - !reference [ .release_push_rules, rules ]
  image: $DOCKER_IMAGE
  services:
    - $DOCKER_SERVICE
  before_script:
    - echo "$DOCKERHUB_PASSWORD" | docker login -u $DOCKERHUB_USER --password-stdin
    - docker pull ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-db:${CI_COMMIT_SHA}
    - docker pull ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-liquibase:${CI_COMMIT_SHA}
    - docker pull ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-backend:${CI_COMMIT_SHA}
    - docker pull ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-frontend:${CI_COMMIT_SHA}
  script:
    - docker tag ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-db:${CI_COMMIT_SHA} iqbberlin/studio-lite-db:${CI_COMMIT_TAG}
    - docker tag ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-db:${CI_COMMIT_SHA} iqbberlin/studio-lite-db:latest
    - docker tag ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-liquibase:${CI_COMMIT_SHA} iqbberlin/studio-lite-liquibase:${CI_COMMIT_TAG}
    - docker tag ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-liquibase:${CI_COMMIT_SHA} iqbberlin/studio-lite-liquibase:latest
    - docker tag ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-backend:${CI_COMMIT_SHA} iqbberlin/studio-lite-backend:${CI_COMMIT_TAG}
    - docker tag ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-backend:${CI_COMMIT_SHA} iqbberlin/studio-lite-backend:latest
    - docker tag ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-frontend:${CI_COMMIT_SHA} iqbberlin/studio-lite-frontend:${CI_COMMIT_TAG}
    - docker tag ${REGISTRY}${REGISTRY_PROJECT}iqbberlin/studio-lite-frontend:${CI_COMMIT_SHA} iqbberlin/studio-lite-frontend:latest
    - docker push -a -q iqbberlin/studio-lite-db
    - docker push -a -q iqbberlin/studio-lite-liquibase
    - docker push -a -q iqbberlin/studio-lite-backend
    - docker push -a -q iqbberlin/studio-lite-frontend
  after_script:
    - docker logout
